<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>从并发角度将final关键字</title>
    <link href="/2023/03/29/%E4%BB%8E%E5%B9%B6%E5%8F%91%E8%A7%92%E5%BA%A6%E5%B0%86final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2023/03/29/%E4%BB%8E%E5%B9%B6%E5%8F%91%E8%A7%92%E5%BA%A6%E5%B0%86final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>final在Java中是一个保留的关键字，可以声明成员变量、方法、类以及本地变量。一旦将引用声明作final，将<strong>不能改变这个引用</strong>了，编译器会检查代码，如果试图将变量再次初始化的话，编译器会报编译错误。</p><h3 id="一、final基本使用"><a href="#一、final基本使用" class="headerlink" title="一、final基本使用"></a>一、final基本使用</h3><p>在<code>Java</code>中，<code>final</code>关键字可以用来修饰<strong>类</strong>、<strong>方法</strong>和<strong>变量（包括成员变量和局部变量）</strong>。</p><h4 id="1-1-修饰类"><a href="#1-1-修饰类" class="headerlink" title="1.1 修饰类"></a>1.1 修饰类</h4><p>当用<code>final</code>修饰一个类时，表明这个类<strong>不能被继承</strong>。最常见是就是String类，任何类都无法继承它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence<br></code></pre></td></tr></table></figure><p><strong>如果一个类永远不会让他被继承</strong>（子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患），<strong>就可以用final进行修饰</strong>。</p><p>注意，final类中的成员变量可以根据需要设置为final，但是它的所有成员方法会被隐式地指定为final方法。在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。<br><strong>解决方法</strong></p><p>设计模式中最重要的两种关系，一种是继承&#x2F;实现；另外一种是组合关系。所以当遇到不能用继承的(final修饰的类),应该考虑用组合。</p><p><strong>如下代码大概写个组合实现的意思</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyString</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String innerString;<br><br>    <span class="hljs-comment">// ...init &amp; other methods</span><br><br>    <span class="hljs-comment">// 支持老的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> innerString.length(); <span class="hljs-comment">// 通过innerString调用老的方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// 添加新方法</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toMyString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-修饰方法"><a href="#1-2-修饰方法" class="headerlink" title="1.2 修饰方法"></a>1.2 修饰方法</h4><p>当父类的方法被<code>final</code>修饰的时候，<strong>子类不能重写父类的该方法</strong>，比如在<code>Object</code>中，<code>getClass()</code>方法就是<code>final</code>的，我们就不能重写该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Object</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想<strong>禁止该方法在子类中被重写</strong>的，可以设置该方法为为<code>final</code>。</p><h5 id="1-2-1-private-final"><a href="#1-2-1-private-final" class="headerlink" title="1.2.1 private final"></a>1.2.1 private final</h5><p>因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，此时子类中就可以定义相同的方法名和参数。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Son</span> <span class="hljs-variable">son</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br>        <span class="hljs-type">Base</span> <span class="hljs-variable">father</span> <span class="hljs-operator">=</span> son;<br>        <span class="hljs-comment">//father.test();</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><p>Base和Son都有方法test(),但是这并不是一种覆盖，<strong>因为private所修饰的方法是隐式的final</strong>，也就是无法被继承，所以更不用说是覆盖了，在Son中的test()方法不过是属于Son的新成员罢了，Son进行向上转型得到father，但是<code>father.test()</code>是不可执行的，因为Base中的test方法是private的，无法被访问到。</p><h5 id="1-2-2-final方法是可以被重载的"><a href="#1-2-2-final方法是可以被重载的" class="headerlink" title="1.2.2 final方法是可以被重载的"></a>1.2.2 final方法是可以被重载的</h5><p>父类的final方法是不能够被子类重写的，但是final方法可以被重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalExampleParent</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(String str)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-修饰参数"><a href="#1-3-修饰参数" class="headerlink" title="1.3 修饰参数"></a>1.3 修饰参数</h4><p>Java允许在参数列表中以声明的方式将参数指明为final，这意味着无法在方法中更改参数引用所指向的对象。这个特性主要用来向匿名内部类传递数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String message)</span> &#123; <span class="hljs-comment">// 将参数指定为 final</span><br>        System.out.println(<span class="hljs-string">&quot;Processing message: &quot;</span> + message);<br>        <span class="hljs-comment">// message = &quot;New message&quot;; 试图更改 final 参数将导致编译错误</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，我们声明了一个名为 <code>process</code> 的方法，并将其中的 <code>message</code> 参数指定为 final。由于 <code>message</code> 已经被声明为 final，所以无法在方法中更改它的值。如果我们尝试在方法中更改 <code>message</code> 的值，编译器将会报错。</p><h4 id="1-4-修饰变量"><a href="#1-4-修饰变量" class="headerlink" title="1.4 修饰变量"></a>1.4 修饰变量</h4><p><strong>final修饰变量表示这个变量一旦赋值就不能修改</strong>。</p><p>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</p><p>如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该<strong>引用所指向的对象的内容是可以发生变化的</strong>，final只保证这个<strong>引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的</strong>。</p><h5 id="1-4-1-成员变量"><a href="#1-4-1-成员变量" class="headerlink" title="1.4.1 成员变量"></a>1.4.1 成员变量</h5><p>Java中，成员变量分为<strong>类变量（static修饰）和实例变量</strong>。</p><p><strong>针对这两种类型的变量赋初值的时机是不同的</strong>：</p><ul><li>类变量可以在<strong>声明变量的时候直接赋初值</strong>或者<strong>在静态代码块中给类变量赋初值</strong>；</li><li>实例变量可以<strong>在声明变量的时候给实例变量赋初值</strong>，<strong>在非静态初始化块中</strong>以及<strong>构造器中赋初值</strong>。</li></ul><p>因此类变量有<strong>两个时机赋初值</strong>，而实例变量则可以有<strong>三个时机赋初值</strong>。</p><p>被final修饰的变量必须在上述时机赋初值，否则编译器会报错。</p><p><strong>总结</strong></p><ul><li><strong>final修饰的类变量</strong>：必须要在<strong>静态初始化块</strong>中指定初始值或者<strong>声明该类变量时</strong>指定初始值，而且只能在这两个地方之一进行指定，一旦赋值后不能再修改。</li><li><strong>final修饰的实例变量</strong>：必要要在<strong>非静态初始化块</strong>，<strong>声明该实例变量</strong>或者<strong>在构造器中</strong>指定初始值，而且只能在这三个地方之一进行指定，一旦赋值后不能再修改。</li></ul><h5 id="1-4-2-局部变量"><a href="#1-4-2-局部变量" class="headerlink" title="1.4.2 局部变量"></a>1.4.2 局部变量</h5><p><code>final</code>局部变量由程序员进行<strong>显式初始化</strong>，如果<code>final</code>局部变量已经进行了初始化则后面就不能再次进行更改，如果<code>final</code>变量未进行初始化，可以进行赋值，<strong>当且仅有一次</strong>赋值，一旦赋值之后再次赋值就会出错。</p><p>当局部变量被final修饰时，它表示该变量的值只能被初始化一次，一旦初始化之后就不能再被修改。下面是一个示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">example</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 定义局部变量num并用final修饰</span><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 在这里使用num，可以读取它的值，</span><br><span class="hljs-comment">     * 但是如果尝试修改num的值将会导致编译错误。</span><br><span class="hljs-comment">     */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码中，变量<code>num</code>被定义为局部变量，并且用<code>final</code>关键字进行修饰。由于该变量被<code>final</code>修饰，因此在函数内部无法更改其值。</p><h3 id="二、final域重排序规则"><a href="#二、final域重排序规则" class="headerlink" title="二、final域重排序规则"></a>二、final域重排序规则</h3><p>前面介绍的只是final关键字的<strong>基础用法</strong>。然而在多线程的层面，final也有其自己的<strong>内存语义</strong>。<strong>主要体现在final域的重排序上</strong>，下面来介绍final的重排序规则。</p><h4 id="2-1-final域为基本类型"><a href="#2-1-final域为基本类型" class="headerlink" title="2.1 final域为基本类型"></a>2.1 final域为基本类型</h4><p>先看一段示例性的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> a;  <span class="hljs-comment">//普通域</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> b; <span class="hljs-comment">//final域</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> FinalDemo finalDemo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalDemo</span><span class="hljs-params">()</span> &#123;<br>        a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 1. 写普通域</span><br>        b = <span class="hljs-number">2</span>; <span class="hljs-comment">// 2. 写final域</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writer</span><span class="hljs-params">()</span> &#123;<br>        finalDemo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalDemo</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">FinalDemo</span> <span class="hljs-variable">demo</span> <span class="hljs-operator">=</span> finalDemo; <span class="hljs-comment">// 3.读对象引用</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> demo.a;    <span class="hljs-comment">//4.读普通域</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> demo.b;    <span class="hljs-comment">//5.读final域</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设线程A在执行writer()方法，随后另一个线程B执行reader()方法。</p><h5 id="2-1-1-写final域重排序规则"><a href="#2-1-1-写final域重排序规则" class="headerlink" title="2.1.1 写final域重排序规则"></a>2.1.1 写final域重排序规则</h5><p>写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：</p><ul><li><strong><u>JMM禁止编译器把final域的写重排序到构造函数之外；</u></strong></li><li><strong><u>编译器会在final域写之后，构造函数return之前，插入一个<code>storestore</code>屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。</u></strong></li></ul><p>我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：</p><ul><li>构造了一个<code>FinalDemo</code>对象；</li><li>把这个对象赋值给成员变量<code>finalDemo</code>。</li></ul><p>我们来画下存在的一种可能执行时序图，如下：</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329214437332.png" alt="image-20230329214437332"></p><p>由于a,b之间没有数据依赖性，普通域(普通变量)a可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量a初始化之前的值(零值)，这样就可能出现错误。而final域变量b，根据重排序规则，会禁止final修饰的变量b重排序到构造函数之外，从而b能够正确赋值，线程B就能够读到final变量初始化后的值。</p><p><strong>因此，写final域的重排序规则可以确保</strong>：</p><p>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象<code>finalDemo</code>。</p><h5 id="2-1-2-读final域重排序规则"><a href="#2-1-2-读final域重排序规则" class="headerlink" title="2.1.2 读final域重排序规则"></a>2.1.2 读final域重排序规则</h5><p><strong>读final域重排序规则为</strong>：</p><p><u><strong>在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。(注意，这个规则仅仅是针对处理器)，处理器会在读final域操作的前面插入一个<code>LoadLoad</code>屏障。</strong></u></p><p>实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序，因此，这条禁止重排序规则就是针对这些处理器而设定的。</p><p><strong>read()方法主要包含了三个操作</strong>：</p><ul><li>初次读引用变量<code>finalDemo</code>;</li><li>初次读引用变量<code>finalDemo</code>的普通域a;</li><li>初次读引用变量<code>finalDemo</code>的final域b;</li></ul><p>假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329214710342.png" alt="image-20230329214710342"></p><p>读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。</p><p><u><strong>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。</strong></u></p><h4 id="2-2-final域为引用类型"><a href="#2-2-final域为引用类型" class="headerlink" title="2.2 final域为引用类型"></a>2.2 final域为引用类型</h4><h5 id="2-2-1-对final修饰的对象的成员域写操作"><a href="#2-2-1-对final修饰的对象的成员域写操作" class="headerlink" title="2.2.1 对final修饰的对象的成员域写操作"></a>2.2.1 对final修饰的对象的成员域写操作</h5><p>针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：</p><p>在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。</p><p>注意这里的是“增加”也就说前面对final基本数据类型的重排序规则在这里还是适用。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalReferenceDemo</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span>[] arrays;<br>    <span class="hljs-keyword">private</span> FinalReferenceDemo finalReferenceDemo;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalReferenceDemo</span><span class="hljs-params">()</span> &#123;<br>        arrays = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];  <span class="hljs-comment">//1</span><br>        arrays[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;        <span class="hljs-comment">//2</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writerOne</span><span class="hljs-params">()</span> &#123;<br>        finalReferenceDemo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalReferenceDemo</span>(); <span class="hljs-comment">//3</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writerTwo</span><span class="hljs-params">()</span> &#123;<br>        arrays[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;  <span class="hljs-comment">//4</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reader</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (finalReferenceDemo != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">//5</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> finalReferenceDemo.arrays[<span class="hljs-number">0</span>];  <span class="hljs-comment">//6</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对上面的实例程序，线程A执行<code>wirterOne</code>方法，执行完后线程B执行<code>writerTwo</code>方法，然后线程C执行reader方法。</p><p>下图就以这种执行时序出现的一种情况来讨论:</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329220923119.png" alt="image-20230329220923119"></p><p>由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。</p><h5 id="2-2-2-对final修饰的对象的成员域读操作"><a href="#2-2-2-对final修饰的对象的成员域读操作" class="headerlink" title="2.2.2 对final修饰的对象的成员域读操作"></a>2.2.2 对final修饰的对象的成员域读操作</h5><p>JMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] &#x3D; 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。</p><h4 id="2-3-关于final重排序的总结（重点）"><a href="#2-3-关于final重排序的总结（重点）" class="headerlink" title="2.3 关于final重排序的总结（重点）"></a>2.3 关于final重排序的总结（重点）</h4><p>按照final修饰的数据类型分类：</p><ul><li>基本数据类型:<ul><li><code>final域写</code>：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。</li><li><code>final域读</code>：禁止初次读对象的引用与读该对象包含的final域的重排序。</li></ul></li><li>引用数据类型：<ul><li><code>额外增加约束</code>：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量 重排序</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子累加器之LongAdder</title>
    <link href="/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8%E4%B9%8BLongAdder/"/>
    <url>/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B4%AF%E5%8A%A0%E5%99%A8%E4%B9%8BLongAdder/</url>
    
    <content type="html"><![CDATA[<h3 id="一、原子累加器对比"><a href="#一、原子累加器对比" class="headerlink" title="一、原子累加器对比"></a>一、原子累加器对比</h3><p>我们通过如下代码，比较<code>synchronized</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>LongAdder</code>、<code>LongAccumulator</code>五种计数性能。</p><p><strong>示例</strong></p><blockquote><p>需求：热点商品点赞计算器，点赞数进行统计，不要求实时精确。50个线程，每个线程100W次，统计总点赞数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> site.weiyikai.demo06;<br><br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAccumulator;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.LongAdder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2023-03-29 19:28</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">//需求：热点商品点赞计算器，点赞数进行统计，不要求实时精确。50个线程，每个线程100W次，统计总点赞数。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClickNumber</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_synchronized</span><span class="hljs-params">()</span>&#123;<br>        number++;<br>    &#125;<br><br>    <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_AtomicInteger</span><span class="hljs-params">()</span>&#123;<br>        atomicInteger.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_AtomicLong</span><span class="hljs-params">()</span>&#123;<br>        atomicLong.incrementAndGet();<br>    &#125;<br><br>    <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_LongAdder</span><span class="hljs-params">()</span>&#123;<br>        longAdder.increment();<br>    &#125;<br><br>    <span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">longAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>((x, y)-&gt;x+y,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add_longAccumulator</span><span class="hljs-params">()</span>&#123;<br>        longAccumulator.accumulate(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongAdderCalcDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE_THREAD</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">_1w</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ClickNumber</span> <span class="hljs-variable">clickNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClickNumber</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch_synchronized</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE_THREAD);<br>        CountDownLatch latch_AtomicInteger= <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE_THREAD);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch_AtomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE_THREAD);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch_LongAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE_THREAD);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch_LongAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(SIZE_THREAD);<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>*_1w; j++) &#123;<br>                        clickNumber.add_synchronized();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch_synchronized.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        latch_synchronized.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;synchronized花费时间：&quot;</span>+ (endTime-startTime)+<span class="hljs-string">&quot; 数值为：&quot;</span>+clickNumber.number);<br><br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>*_1w; j++) &#123;<br>                        clickNumber.add_AtomicInteger();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch_AtomicInteger.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        latch_AtomicInteger.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;AtomicInteger花费时间：&quot;</span>+ (endTime-startTime)+<span class="hljs-string">&quot; 数值为：&quot;</span>+clickNumber.atomicInteger.get());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>*_1w; j++) &#123;<br>                        clickNumber.add_AtomicLong();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch_AtomicLong.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        latch_AtomicLong.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;AtomicLong花费时间：&quot;</span>+ (endTime-startTime)+<span class="hljs-string">&quot; 数值为：&quot;</span>+clickNumber.atomicLong.get());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>*_1w; j++) &#123;<br>                        clickNumber.add_LongAdder();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch_LongAdder.countDown();<br>                &#125;<br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        latch_LongAdder.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;LongAdder花费时间：&quot;</span>+ (endTime-startTime)+<span class="hljs-string">&quot; 数值为：&quot;</span>+clickNumber.longAdder.longValue());<br><br>        startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= SIZE_THREAD; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">100</span>*_1w; j++) &#123;<br>                        clickNumber.add_longAccumulator();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch_LongAccumulator.countDown();<br>                &#125;<br><br>            &#125;,String.valueOf(i)).start();<br>        &#125;<br>        latch_LongAccumulator.await();<br>        endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;LongAccumulator花费时间：&quot;</span>+ (endTime-startTime)+<span class="hljs-string">&quot; 数值为：&quot;</span>+clickNumber.longAccumulator.longValue());<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">synchronized</span>花费时间：<span class="hljs-number">1314</span> 数值为：<span class="hljs-number">50000000</span><br>AtomicInteger花费时间：<span class="hljs-number">609</span> 数值为：<span class="hljs-number">50000000</span><br>AtomicLong花费时间：<span class="hljs-number">639</span> 数值为：<span class="hljs-number">50000000</span><br>LongAdder花费时间：<span class="hljs-number">94</span> 数值为：<span class="hljs-number">50000000</span><br>LongAccumulator花费时间：<span class="hljs-number">45</span> 数值为：<span class="hljs-number">50000000</span><br></code></pre></td></tr></table></figure><p>通过上面的代码运行我们可以清晰地看到，每种方式都有效的产完成了累加的效果，但是明显使用<strong>LongAdder</strong>的效率要更好，甚至要高出<strong>AtomicLong</strong>好几倍。</p><p>现在，我们可以简单地理解为，原子累加器就是JAVA在并发编程下提供的有保障的累加手段。</p><p>那么<code>LongAdder</code>是如何做的这一点的呢？接下来我们慢慢进行分析。</p><h3 id="二、LongAdder概述"><a href="#二、LongAdder概述" class="headerlink" title="二、LongAdder概述"></a>二、LongAdder概述</h3><p>JDK1.8时，<code>java.util.concurrent.atomic</code>包中提供了一个新的原子类：<code>LongAdder</code>。</p><p>根据Oracle官方文档的介绍，<code>LongAdder</code>在高并发的场景下会比它的前辈<code>AtomicLong</code> 具有更好的性能，代价是消耗更多的内存空间。</p><ul><li><strong>AtomicLong存在的问题</strong></li></ul><p> 在并发量较低的环境下，线程冲突的概率比较小，自旋的次数不会很多。但是，高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时<code>AtomicLong</code>的自旋会成为瓶颈。</p><p> 这就是<code>LongAdder</code>引入的初衷,解决高并发环境下<code>AtomicLong</code>的自旋瓶颈问题。</p><ul><li><strong>使用场景</strong></li></ul><p> 在大数据处理过程，为了方便监控，需要统计数据，少不了原子计数器。为了尽量优化性能，需要采用高效的原子计数器。<br>​ 在jdk8中，引入了<code>LongAdder</code>，非常适合多线程原子计数器。与<code>AtomicLong</code>做了一个测试，<code>LongAdder</code>在多线程环境中，原子自增长性能要好很多。它常用于状态采集、统计等场景。</p><h3 id="三、LongAdder原理"><a href="#三、LongAdder原理" class="headerlink" title="三、LongAdder原理"></a>三、LongAdder原理</h3><h4 id="3-1-AtomicLong和LongAdder比较"><a href="#3-1-AtomicLong和LongAdder比较" class="headerlink" title="3.1 AtomicLong和LongAdder比较"></a>3.1 AtomicLong和LongAdder比较</h4><ul><li><strong>AtomicLong</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329195927478.png" alt="image-20230329195927478"></p><p><code>AtomicLong</code>中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value变量其实是一个热点，也就是N个线程竞争一个热点。</p><ul><li><strong>LongAdder</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329195947760.png" alt="image-20230329195947760"></p><p><code>LongAdder</code>的基本思路就是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。如果要获取真正的long值，只要将各个槽中的变量值累加返回。</p><p><code>AtomicLong</code>是多个线程针对单个热点值value进行原子操作。而<code>LongAdder</code>是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行CAS操作。</p><h4 id="3-2-原理"><a href="#3-2-原理" class="headerlink" title="3.2 原理"></a>3.2 原理</h4><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329200103587.png" alt="image-20230329200103587"></p><p><code>LongAdder</code> 在无竞争条件下，跟 <code>AtomicInteger</code> 一样，对同一个 base 进行操作。</p><p>当出现了多线程竞争时采用化整为零的做法，用空间换时间，用一个数组<code>cells[]</code>，将一个 value 拆分进这个 <code>cells[]</code> 数组，多线程同时对各个 cell 中的 value 进行操作，可以对线程 id 进行 hash，再根据 hash 映射到这个数组的某个索引，然后对 cell 中的 value 进行 cas 操作，当所有线程都执行完毕，累加所有 cell 中的value 值 和 无竞争下的 base 即为最终结果。<br>总结一句公式： <strong>LongAdder &#x3D; base基础数据 + cell[] + CAS</strong> 操作，用空间换时间所以快。</p><h3 id="四、基类Striped64内部三个重要成员"><a href="#四、基类Striped64内部三个重要成员" class="headerlink" title="四、基类Striped64内部三个重要成员"></a>四、基类Striped64内部三个重要成员</h3><p><code>LongAdder</code> 继承于 <code>Stripped64</code> 类，<code>base</code> 值和 <code>cell</code> 数组都在 <code>Stripped64</code> 类中定义，它的内部三个重要的成员如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 成员一：存放Cell的哈希表，大小为2的幂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 成员二：基础值</span><br><span class="hljs-comment"> * 1.在没有竞争时会更新这个值</span><br><span class="hljs-comment"> * 2.在cells初始化时，cells不可用，也会尝试通过CAS操作值累加到base</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自旋锁，通过CAS操作加锁，为0表示cells数组没有处于创建、扩容阶段</span><br><span class="hljs-comment"> * 为1表示正在创建或者扩展cells数组，不能进行新Cell元素的设置操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br></code></pre></td></tr></table></figure><p><code>Stripped64</code> 内部包含一个 <code>base</code> 和一个 <code>Cell[]</code> 类型的 <code>cells</code> 数组，<code>cells</code> 数组又叫哈希表，在没有竞争的情况下，要累加的数通过CAS累加到 <code>base</code> 上，如果有竞争的话，会将要累加的数累加到 <code>cells</code> 数组中的某个 <code>Cell</code> 元素里面。</p><p><code>Stripped64</code> 的整体值 <code>value</code> 的获取函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">longValue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sum();<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将多个cells数组中的值加起来的和</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sum</span><span class="hljs-params">()</span> &#123;<br>    Cell[] as = cells; <br>    Cell a;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> base;<br>    <span class="hljs-keyword">if</span> (as != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; as.length; ++i) &#123;<br>            <span class="hljs-keyword">if</span> ((a = as[i]) != <span class="hljs-literal">null</span>)<br>                sum += a.value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Stripped64</code> 的设计核心思路是通过内部的分散计算来避免竞争，以空间换取时间。没有竞争时 <code>cells</code> 数组为 null，这时只使用 <code>base</code>，一旦发生竞争，<code>cells</code> 数组就上场了。</p><p><code>cells</code> 数组第一次初始化长度为2，以后每次扩容都变为原来的两倍，一直到 <code>cells</code> 数组的长度大于等于当前服务器的CPU核数，同一时刻能持有CPU时间片去并发操作同一内存地址的最大线程数最多也就是CPU的核数。</p><p>在存在线程争用的时候，每个线程被映射到 <code>cells[threadLocalRandomProbe&amp;cells.length]</code> 位置的 Cell 元素，该线程对 <code>value</code> 所做的累加操作就执行在对应的 <code>Cell</code> 元素的值上。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子类之字段更新器</title>
    <link href="/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8B%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8/"/>
    <url>/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8B%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>前面所讲的几个原子更新引用类型如：<code>AtomicReference</code>，用于整个对象的更新。但不是每次都必须更新整个对象，有可能我们只需对对象中的某个字段进行原子性修改时，那么就需要使用原子更新字段类。</p><p>在<code>java.util.concurrent.atomic</code>中，原子类型字段更新器有以下三种：</p><ul><li><code>AtomicIntegerFieldUpdater</code>：基于反射的工具类，可以原子性的更新指定对象的指定int类型字段。</li><li><code>AtomicLongFieldUpdater</code>：基于反射的工具类，可以原子性的更新指定对象的指定long类型字段。</li><li><code>AtomicReferenceFieldUpdater</code>：基于反射的工具类，可以原子性的更新指定对象的指定应用类型字段。</li></ul><h3 id="二、使用条件"><a href="#二、使用条件" class="headerlink" title="二、使用条件"></a>二、使用条件</h3><p>原子类型字段更新器在内部通过Unsafe类的native方法保证操作的原子性。</p><p>关于原子类型字段更新器的使用需要注意以下几个方面：</p><ul><li><p>字段必须是volatile类型的，用于保证可见性。</p></li><li><p>字段和字段更新器的访问类型(public&#x2F;protected&#x2F;private)必须一致。</p></li><li><p>字段只能是实例变量，不能是类变量(static)。</p></li><li><p>字段不能是final的变量，这样的字段不可修改。</p></li><li><p>如果要处理Integer和Long类型，则需要使用<code>AtomicReferenceFieldUpdater</code>。</p></li><li><p>属性必须对当前的Updater所在的区域是可见的，如果不是当前类内部进行原子更新器操作不能使用private，protected子类操作父类时修饰符必须是protect权限及以上，如果在同一个package下则必须是default权限及以上，也就是说无论何时都应该保证操作类与被操作类间的可见性。</p></li><li><p>对于 <code>AtomicIntegerFieldUpdate</code> 和 <code>AtomicLongFieldUpdate</code> 只能修改 int&#x2F;long 类型的字段，不能修改包装类型。如果要修改包装类型就需要使用 <code>AtomicReferenceFieldUpdate</code>。</p></li></ul><p><strong>示例</strong></p><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 volatile 修饰的字段使用，否则会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicIntegerFieldUpdater;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test05</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> field;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AtomicIntegerFieldUpdater</span> <span class="hljs-variable">fieldUpdater</span> <span class="hljs-operator">=</span> AtomicIntegerFieldUpdater.newUpdater(Test05.class, <span class="hljs-string">&quot;field&quot;</span>);<br><br>        <span class="hljs-type">Test05</span> <span class="hljs-variable">test5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test05</span>();<br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>        <span class="hljs-comment">// 修改成功 field = 10</span><br>        System.out.println(test5.field);<br>        <span class="hljs-comment">// 修改成功 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        System.out.println(test5.field);<br>        <span class="hljs-comment">// 修改失败 field = 20</span><br>        fieldUpdater.compareAndSet(test5, <span class="hljs-number">10</span>, <span class="hljs-number">30</span>);<br>        System.out.println(test5.field);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">10<br>20<br>20<br></code></pre></td></tr></table></figure><h3 id="三、主要方法"><a href="#三、主要方法" class="headerlink" title="三、主要方法"></a>三、主要方法</h3><h5 id="三者共有的方法"><a href="#三者共有的方法" class="headerlink" title="三者共有的方法"></a>三者共有的方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>static &lt;U&gt; AtomicIntFieldUpdater&lt;U&gt; newUpdater(Class&lt;U&gt; tclass, String fieldName)</code></td><td>原子类型字段更新器提供的一个静态泛型方法，用于创建和返回指定字段和指定类型的原子类型字段更新器实例对象</td></tr><tr><td><code>abstract V get(T obj)</code></td><td>获取此更新器管理的在给定对象的字段中保持的当前值</td></tr><tr><td><code>abstract void set(T obj, int newValue)</code></td><td>将此更新器管理的给定对象的字段设置为给定更新值</td></tr><tr><td><code>abstract void lazySet(T obj, int newValue)</code></td><td>最后将此更新器管理的给定对象的字段设置为给定更新值</td></tr><tr><td><code>int getAndSet(T obj, int newValue)</code></td><td>将此更新器管理的给定对象的字段以原子方式设置为给定值，并返回旧值</td></tr><tr><td><code>abstract boolean compareAndSet(T obj, int expect, int update)</code></td><td>如果当前值 &#x3D;&#x3D; 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值</td></tr><tr><td><code>abstract boolean weakCompareAndSet(T obj, int expect, int update)</code></td><td>如果当前值 &#x3D;&#x3D; 预期值，则以原子方式将此更新器所管理的给定对象的字段设置为给定的更新值</td></tr></tbody></table><h5 id="AtomicIntegerFieldUpdater和AtomicLongFieldUpdater的独有方法："><a href="#AtomicIntegerFieldUpdater和AtomicLongFieldUpdater的独有方法：" class="headerlink" title="AtomicIntegerFieldUpdater和AtomicLongFieldUpdater的独有方法："></a><code>AtomicIntegerFieldUpdater</code>和<code>AtomicLongFieldUpdater</code>的独有方法：</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>int addAndGet(T obj, int delta)</code></td><td>以原子的方式将给定值和更新器管理的给定对象的当前值相加,并返回相加后的值</td></tr><tr><td><code>int incrementAndGet(T obj)</code></td><td>以原子方式将此更新器管理的给定对象字段当前值加 1</td></tr><tr><td><code>int decrementAndGet(T obj)</code></td><td>以原子方式将此更新器管理的给定对象字段当前值减<code>1</code></td></tr><tr><td><code>int getAndIncrement(T obj)</code></td><td>以原子方式将此更新器管理的给定对象字段的当前值加 1</td></tr><tr><td><code>int getAndAdd(T obj, int delta)</code></td><td>以原子方式将给定值添加到此更新器管理的给定对象的字段的当前值</td></tr><tr><td><code>int getAndDecrement(T obj)</code></td><td>以原子方式将此更新器管理的给定对象字段当前值减 1</td></tr></tbody></table><p><strong>lazySet与set实现的功能类似，二者区别如下：</strong></p><ul><li><code>lazySet</code>实现的是最终一致性，set实现的是强一致性</li><li><code>lazySet</code>多线程并发时，线程A调用<code>unsafe.putOrderedInt</code>更新<code>newValue</code>值时，只是把线程A内存中的元素更新成功了，但其它线程此时看不到线程A更新的<code>newValue</code>值，需过一会，线程A更新的<code>newValue</code>才会刷入到主内存中，此时其它线程才能看到线程A更新的值</li><li>set方法在多线程并发时，线程A更新的值会立即刷入主内存中</li></ul><p><strong>总结：对于数据一致性要求高的建议用set</strong></p><h5 id="比较设置方法compareAndSet"><a href="#比较设置方法compareAndSet" class="headerlink" title="比较设置方法compareAndSet"></a>比较设置方法compareAndSet</h5><p><code>compareAndSet()方法</code>: 如果当前值 &#x3D;&#x3D; 预期值，则以原子方式将此更新程序所管理的给定对象的字段值设置为给定的更新值。</p><p>对 <code>compareAndSet</code> 和 <code>set</code> 的其他调用，此方法可以确保原子性，但对于字段中的其他更改则不一定确保原子性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">compareAndSet(T obj, V expect, V update)<br></code></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>obj - 有条件地设置其字段的对象</li><li>expect - 预期值</li><li>update - 新值</li></ul><p><strong>返回</strong>：如果成功，则返回 true</p><h5 id="比较设置方法weakCompareAndSet"><a href="#比较设置方法weakCompareAndSet" class="headerlink" title="比较设置方法weakCompareAndSet"></a>比较设置方法weakCompareAndSet</h5><p><code>weakCompareAndSet()方法</code>: 如果当前值 &#x3D;&#x3D; 预期值，则以原子方式将此更新程序所管理的给定对象的字段值设置为给定的更新值。</p><p>对 <code>compareAndSet</code> 和 set 的其他调用，此方法可以确保原子性，但对于字段中的其他更改则不一定确保原子性，并且可能会意外失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">weakCompareAndSet(T obj, V expect, V update)<br></code></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li>obj - 有条件地设置其字段的对象</li><li>expect - 预期值</li><li>update - 新值</li></ul><p><strong>返回</strong>：如果成功，则返回 true。</p><h3 id="四、使用"><a href="#四、使用" class="headerlink" title="四、使用"></a>四、使用</h3><h4 id="4-1-实例的创建"><a href="#4-1-实例的创建" class="headerlink" title="4.1 实例的创建"></a>4.1 实例的创建</h4><ul><li><strong>构造方法</strong></li></ul><p><code>AtomicReferenceFieldUpdater</code> 有一个 protected 的无参数构造方法，只能供子类使用。所以一般情况下创建一个 <code>AtomicReferenceFieldUpdater</code> 实例需要使用该类提供的一个静态方法 <code>newUpdater</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 受保护的无操作构造方法，供子类使用。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">AtomicReferenceFieldUpdater</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><ul><li><strong>创建实例的静态方法newUpdater</strong></li></ul><p><code>AtomicReferenceFieldUpdater</code> 可以为一个用于更新指定类的声明为volatile类型的属性进行原子性更新，通过调用 <code>AtomicReferenceFieldUpdater</code> 的静态方法 <code>newUpdater</code> 创建实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U,W&gt; AtomicReferenceFieldUpdater&lt;U,W&gt; <span class="hljs-title function_">newUpdater</span><span class="hljs-params">(Class&lt;U&gt; tclass,</span><br><span class="hljs-params">                                                                Class&lt;W&gt; vclass,</span><br><span class="hljs-params">                                                                String fieldName)</span><br></code></pre></td></tr></table></figure><p><strong>参数</strong>：</p><ul><li><code>tclass</code>：包含要更新属性&#x2F;字段的类的类型，即需要更新字段所在的class类。</li><li><code>vclass</code> ： 更新属性&#x2F;字段所属的类型。</li><li><code>fieldName</code> ：更新属性&#x2F;字段的名称。</li></ul><p><strong>返回</strong>：更新程序</p><p><strong>抛出</strong>：</p><ul><li><code>IllegalArgumentException</code> - 如果该字段不是可变引用类型。</li><li><code>RuntimeException</code> - 如果该类不保持字段，或者是错误的类型，将抛出 <code>RuntimeException</code> 和一个嵌套的基于反射的异常。</li></ul><h4 id="4-2-方法使用"><a href="#4-2-方法使用" class="headerlink" title="4.2 方法使用"></a>4.2 方法使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> site.weiyikai.demo06;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;<br><span class="hljs-keyword">import</span> java.util.function.BinaryOperator;<br><span class="hljs-keyword">import</span> java.util.function.UnaryOperator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2023-03-29 19:09</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span> &#123;<br>    <span class="hljs-comment">//abstract</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Integer age;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化采用静态方法+内部类，私有化构造函数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNewUpdater</span><span class="hljs-params">()</span> &#123;<br>        AtomicReferenceFieldUpdaterTest test=<span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-comment">//获取此更新器管理的在给定对象的字段中保持的当前值</span><br>        System.out.println(updater.get(test)); <span class="hljs-comment">//null</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果指定对象的目标属性值为expect的值，则更新成新值，返回true</span><br><span class="hljs-comment">     * 否则不更新，返回false</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCompareAndSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(updater.compareAndSet(test, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));<br>        System.out.println(updater.get(test));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果指定对象的目标属性值为expect的值，则更新成新值，返回true</span><br><span class="hljs-comment">     * 否则不更新，返回false</span><br><span class="hljs-comment">     * weakCompareAndSet和compareAndSet暂时未发现区别</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWeakCompareAndSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(updater.weakCompareAndSet(test, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));<br>        System.out.println(updater.get(test));<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置指定对象的目标属性值为新的值，unsafe.putIntVolatile设置值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        updater.set(test, <span class="hljs-number">22</span>);<br>        System.out.println(updater.get(test));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置指定对象的目标属性值为新的值，unsafe.putOrderedInt</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLazySet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        updater.lazySet(test, <span class="hljs-number">22</span>);<br>        System.out.println(updater.get(test));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取指定对象的目标属性值，需要检查是否越界</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(updater.get(test));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回指定对象的目标属性值，并设置成新的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetAndSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        System.out.println(updater.getAndSet(test, <span class="hljs-number">32</span>));<br>        System.out.println(updater.get(test));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回指定对象的目标属性值，并更新成新值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetAndUpdate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-type">UnaryOperator</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnaryOperator</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(Object o)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">333</span>);<br>            &#125;<br>        &#125;;<br>        System.out.println(updater.getAndUpdate(test, operator));<br>        System.out.println(updater.get(test));<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新成新值并返回指定对象的目标属性值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testUpdateAndGet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-type">UnaryOperator</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnaryOperator</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(Object o)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">333</span>);<br>            &#125;<br>        &#125;;<br>        System.out.println(updater.updateAndGet(test, operator));<br>        System.out.println(updater.get(test));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回指定对象的目标属性值，并更新成新值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetAndAccumulate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-type">BinaryOperator</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryOperator</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(Object o, Object o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2;<br>            &#125;<br>        &#125;;<br>        System.out.println(updater.getAndAccumulate(test, <span class="hljs-number">2</span>, operator));<br>        System.out.println(updater.get(test));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新成新值并返回指定对象的目标属性值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAccumulateAndGet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AtomicReferenceFieldUpdaterTest</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceFieldUpdaterTest</span>();<br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span> AtomicReferenceFieldUpdater.newUpdater(AtomicReferenceFieldUpdaterTest.class, Integer.class,<span class="hljs-string">&quot;age&quot;</span>);<br>        <span class="hljs-type">BinaryOperator</span> <span class="hljs-variable">operator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryOperator</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">apply</span><span class="hljs-params">(Object o, Object o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2;<br>            &#125;<br>        &#125;;<br>        System.out.println(updater.accumulateAndGet(test, <span class="hljs-number">2</span>, operator));<br>        System.out.println(updater.get(test));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子类之原子数组</title>
    <link href="/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <url>/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8B%E5%8E%9F%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一、数组类型的原子类"><a href="#一、数组类型的原子类" class="headerlink" title="一、数组类型的原子类"></a>一、数组类型的原子类</h3><p>原子数组类型，这个其实和<code>AtomicInteger</code>等类似，只不过在修改时需要指明数组下标。</p><p>CAS是按照<code>==</code>来根据地址进行比较。数组比较地址，肯定是不行的，只能比较下标元素。而比较下标元素，就和元素的类型有关系了。</p><p><strong>在<code>java.util.concurrent.atomic</code>中，原子类型数组有以下四种：</strong></p><table><thead><tr><th>类名</th><th>说明</th></tr></thead><tbody><tr><td><code>AtomicIntegerArray</code></td><td>提供对int[]数组元素的原子性更新操作</td></tr><tr><td><code>AtomicLongArray</code></td><td>提供对long[]数组元素的原子性更新操作</td></tr><tr><td><code>AtomicReferenceArray</code></td><td>提供对<code>引用类型[]</code>数组元素的原子性更新操作</td></tr><tr><td><code>AtomicBooleanArray</code></td><td>原子更新布尔类型数组的元素</td></tr></tbody></table><p>使用原子的方式更新数组里的某个元素。</p><h3 id="二、常用方法"><a href="#二、常用方法" class="headerlink" title="二、常用方法"></a>二、常用方法</h3><p>其中<code>AtomicIntegerArray</code>和<code>AtomicLongArray</code>的使用方式差别不大，<code>AtomicReferenceArray</code>因为他的参数为引用数组，所以跟前两个的使用方式有所不同。<code>AtomicBooleanArray</code>在生产中使用的很少。</p><p>本次只对<code>AtomicLongArray</code>和<code>AtomicReferenceArray</code>方法进行详细的介绍。</p><h4 id="2-1-AtomicLongArray介绍"><a href="#2-1-AtomicLongArray介绍" class="headerlink" title="2.1 AtomicLongArray介绍"></a>2.1 AtomicLongArray介绍</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>AtomicLongArray(int length)</td><td>创建给定长度的新 <code>AtomicLongArray</code></td></tr><tr><td>AtomicLongArray(long[] array)</td><td>创建与给定数组具有相同长度的新 <code>AtomicLongArray</code>，并从给定数组复制其所有元素</td></tr></tbody></table><p><strong>源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实例化一个AtomicLongArray，设置数组大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicLongArray</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;<br>    array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[length];<br>&#125;<br><br><span class="hljs-comment">//创建一个新的AtomicLongArray,并给定一个数组初始化</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicLongArray</span><span class="hljs-params">(<span class="hljs-type">long</span>[] array)</span> &#123;<br>    <span class="hljs-comment">// Visibility guaranteed by final field guarantees</span><br>    <span class="hljs-built_in">this</span>.array = array.clone();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>long getAndIncrement(int i)</code></td><td>以原子方式将索引 <code>i</code> 的元素自增 <code>1</code>，并返回旧值</td></tr><tr><td><code>long incrementAndGet(int i)</code></td><td>以原子方式将索引 <code>i</code> 的元素自增 <code>1</code>，并返回减少之后的值</td></tr><tr><td><code>long getAndDecrement(int i)</code></td><td>以原子形式将索引<code>i</code>处的元素原子自减<code>1</code>，并返回旧值</td></tr><tr><td><code>long decrementAndGet(int i)</code></td><td>以原子形式将索引<code>i</code>处的元素原子自减<code>1</code>，并返回减少之后的值</td></tr><tr><td><code>long addAndGet(int i, long delta)</code></td><td>以原子形式将给定元素与数组中索引<code>i</code>的元素相加</td></tr><tr><td><code>long getAndSet(int i, long newValue)</code></td><td>将地位<code>i</code>处的元素原子设置为给定值，并返回旧值</td></tr><tr><td><code>long getAndIncrement(int i)</code></td><td>原子的将给定的值增加到索引<code>i</code>的元素</td></tr><tr><td><code>long get(int i)</code></td><td>获取位置 <code>i</code> 的当前值</td></tr><tr><td><code>void lazySet(int i, long newValue)</code></td><td>最终将位置 <code>i</code> 的元素设置为给定值</td></tr><tr><td><code>int length()</code></td><td>返回数组的长度</td></tr><tr><td><code>void set(int i, long newValue)</code></td><td>将位置 <code>i</code> 的元素设置为给定值</td></tr><tr><td><code>boolean compareAndSet（int i，int expect，int update）</code></td><td>如果当前值 <code>==</code> 预期值，则以原子方式将该值设置为给定的更新值。</td></tr><tr><td><code>boolean weakCompareAndSet(int i, int expect, long update)</code></td><td>如果当前值 <code>==</code> 预期值，则以原子方式将位置 <code>i</code> 的元素设置为给定的更新值</td></tr><tr><td><code>long getAndUpdate(int i, LongUnaryOperator updateFunction)</code></td><td>应用将给定函数利用以后值和给定值的原子更新以后值，返回旧值</td></tr><tr><td><code>long updateAndGet(int i, LongUnaryOperator updateFunction)</code></td><td>应用将给定函数利用以后值和给定值的原子更新以后值，返回新值</td></tr></tbody></table><h5 id="方法示例"><a href="#方法示例" class="headerlink" title="方法示例"></a>方法示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLongArray;<br><span class="hljs-keyword">import</span> java.util.function.LongBinaryOperator;<br><span class="hljs-keyword">import</span> java.util.function.LongUnaryOperator;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-11-07</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> AtomicLongArray示例</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicExample</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化 数组长度为 10</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicLongArray</span> <span class="hljs-variable">arr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLongArray</span>(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">LongUnaryOperator</span> <span class="hljs-variable">longUnaryOperator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongUnaryOperator</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">applyAsLong</span><span class="hljs-params">(<span class="hljs-type">long</span> operand)</span> &#123;<br>            <span class="hljs-comment">// 以后索引 + 10</span><br>            <span class="hljs-keyword">return</span> operand + <span class="hljs-number">10</span>;<br>        &#125;<br><br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">LongBinaryOperator</span> <span class="hljs-variable">accumulatorFunction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongBinaryOperator</span>() &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">applyAsLong</span><span class="hljs-params">(<span class="hljs-type">long</span> left, <span class="hljs-type">long</span> right)</span> &#123;<br>            <span class="hljs-keyword">return</span> left + right;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;i-&quot;</span> + i + <span class="hljs-string">&quot;=&quot;</span> + arr.get(i));<br>        &#125;<br><br>        <span class="hljs-comment">// 以原子形式给以后索引下标为（0）值加1，返回新值 （i++）： 0</span><br>        System.out.println(<span class="hljs-string">&quot;索引 0 incrementAndGet=&quot;</span> + arr.getAndIncrement(<span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">// 以原子形式给以后索引下标为（0）值加1，，返回新值（++i）  两次减少 ： 2</span><br>        System.out.println(<span class="hljs-string">&quot;索引 0 incrementAndGet=&quot;</span> + arr.incrementAndGet(<span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//以原子形式给以后索引下标为（0）值缩小 1，返回旧值 （i--）：2</span><br>        System.out.println(<span class="hljs-string">&quot;索引 0 incrementAndGet=&quot;</span> + arr.getAndDecrement(<span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">//以原子形式给以后索引下标为（0）值缩小 1，返回旧值 （--i）：0</span><br>        System.out.println(<span class="hljs-string">&quot;索引 0 incrementAndGet=&quot;</span> + arr.decrementAndGet(<span class="hljs-number">0</span>));<br><br>        <span class="hljs-comment">// 以原子形式将输出的数值与实例中的值（AtomicLongArray（0）里的value）相加，并返回后果 : 100</span><br>        System.out.println(<span class="hljs-string">&quot;索引 0 addAndGet=&quot;</span> + arr.addAndGet(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>));<br><br>        <span class="hljs-comment">// 获取 AtomicLongArray 的 value 100</span><br>        System.out.println(<span class="hljs-string">&quot;索引 0 get=&quot;</span> + arr.get(<span class="hljs-number">0</span>));<br><br>        System.out.println(<span class="hljs-string">&quot;*********** JDK 1.8 ***********&quot;</span>);<br><br>        <span class="hljs-comment">//应用将给定函数利用给以后值和给定值的后果原子更新以后值，返回上一个值</span><br>        <span class="hljs-comment">// 索引下标为 0 执行指定函数 后果为 100 + 10</span><br>        System.out.println(<span class="hljs-string">&quot;索引 0 getAndUpdate=&quot;</span> + arr.updateAndGet(<span class="hljs-number">0</span>, longUnaryOperator));<br><br>        <span class="hljs-comment">// 索引下标为 1 执行指定函数 后果为 0 + 10</span><br>        System.out.println(<span class="hljs-string">&quot;索引 1 getAndUpdate=&quot;</span> + arr.updateAndGet(<span class="hljs-number">1</span>, longUnaryOperator));<br><br>        <span class="hljs-comment">// 应用给定函数利用给指定下标和给定值的后果原子更新以后值，并返回后果 20</span><br>        System.out.println(<span class="hljs-string">&quot;索引 1 accumulateAndGet=&quot;</span> + arr.accumulateAndGet(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, accumulatorFunction));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown">i-0=0<br>i-1=0<br>i-2=0<br>i-3=0<br>i-4=0<br>索引 0 incrementAndGet=0<br>索引 0 incrementAndGet=2<br>索引 0 incrementAndGet=2<br>索引 0 incrementAndGet=0<br>索引 0 addAndGet=100<br>索引 0 get=100<br><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">*** JDK 1.8 **</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>索引 0 getAndUpdate=110<br>索引 1 getAndUpdate=10<br>索引 1 accumulateAndGet=20<br></code></pre></td></tr></table></figure><h4 id="2-2-AtomicReferenceArray介绍"><a href="#2-2-AtomicReferenceArray介绍" class="headerlink" title="2.2 AtomicReferenceArray介绍"></a>2.2 AtomicReferenceArray介绍</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>AtomicReferenceArray(E[] array)</td><td>创建与给定数组具有相同长度的新 <code>AtomicReferenceArray</code>，并从给定数组复制其所有元素</td></tr><tr><td>AtomicReferenceArray(int length)</td><td>创建给定长度的新 AtomicReferenceArray</td></tr></tbody></table><p><strong>源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicReferenceArray</span><span class="hljs-params">(<span class="hljs-type">int</span> length)</span> &#123;<br>    array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[length];<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AtomicReferenceArray</span><span class="hljs-params">(E[] array)</span> &#123;<br>    <span class="hljs-comment">// Visibility guaranteed by final field guarantees</span><br>    <span class="hljs-built_in">this</span>.array = Arrays.copyOf(array, array.length, Object[].class);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td><code>boolean compareAndSet(int i, E expect, E update)</code></td><td>如果当前值 <code>==</code> 预期值，则以原子方式将位置 i 的元素设置为给定的更新值</td></tr><tr><td><code>E get(int i)</code></td><td>获取位置 <code>i</code> 的当前值</td></tr><tr><td><code>E getAndSet(int i, E newValue)</code></td><td>以原子方式将位置 <code>i</code> 的元素设置为给定值，并返回旧值</td></tr><tr><td><code>void lazySet(int i, E newValue)</code></td><td>最终将位置 <code>i</code> 的元素设置为给定值</td></tr><tr><td><code>int length()</code></td><td>返回该数组的长度</td></tr><tr><td><code>void set(int i, E newValue)</code></td><td>将位置 <code>i</code> 的元素设置为给定值</td></tr><tr><td><code>boolean weakCompareAndSet(int i, E expect, E update)</code></td><td>如果当前值 <code>==</code> 预期值，则以原子方式将位置 <code>i</code> 的元素设置为给定的更新值</td></tr></tbody></table><h5 id="方法示例-1"><a href="#方法示例-1" class="headerlink" title="方法示例"></a>方法示例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReferenceArray;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-11-07</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> AtomicReferenceArray示例</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicReferenceArrayTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Long[] l = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Long</span>[<span class="hljs-number">4</span>];<br>        String[] s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-type">int</span>[] i = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">4</span>];<br>        Integer[] in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[<span class="hljs-number">4</span>];<br>        <span class="hljs-type">AtomicReferenceArray</span> <span class="hljs-variable">atomicReferenceArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceArray</span>(l);<br>        System.out.println(atomicReferenceArray.length());<br>        System.out.println(atomicReferenceArray.get(<span class="hljs-number">2</span>));<br><br>        <span class="hljs-type">AtomicReferenceArray</span> <span class="hljs-variable">atomic</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReferenceArray</span>(<span class="hljs-number">4</span>);<br>        atomic.set(<span class="hljs-number">0</span>,<span class="hljs-number">12</span>);<br>        atomic.set(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;Leefs&quot;</span>);<br>        atomic.set(<span class="hljs-number">3</span>,i);<br>        System.out.println(atomic.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-number">4</span><br><span class="hljs-literal">null</span><br>[<span class="hljs-number">12</span>, <span class="hljs-literal">null</span>, Leefs, [<span class="hljs-symbol">I@</span>63947c6b]<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：</p><ul><li>当使用<code>AtomicReferenceArray(E[] array)</code>这个构造方法传入一个数组对象时，该数组对象必须是引用类型，int[]不可以，但是Integer[]的可以。</li><li>当使用<code>AtomicReferenceArray(int length)</code>这个构造函数的时候，只要为他指定了数组大小之后，为数组的每一位设置什么值是没有要求的，类似于Map的形式。</li></ul><h3 id="三、原子性测试"><a href="#三、原子性测试" class="headerlink" title="三、原子性测试"></a>三、原子性测试</h3><blockquote><p>创建10个线程，每个线程分别对数组操作（自增）10000次（采用了函数式编程）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 参数1:提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment"> 参数2:获取数组长度的方法</span><br><span class="hljs-comment"> 参数3:自增方法，回传 array, index</span><br><span class="hljs-comment"> 参数4:打印数组的方法</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// supplier 提供者 无中生有 ()-&gt;结果</span><br><span class="hljs-comment">// function 函数 一个参数一个结果 (参数)-&gt;结果, BiFunction (参数1,参数2)-&gt;结果</span><br><span class="hljs-comment">// consumer 消费者 一个参数没结果 (参数)-&gt;void, BiConsumer (参数1,参数2)-&gt;void</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">    Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">    Function&lt;T,Integer&gt; lengthFun,</span><br><span class="hljs-params">    BiConsumer&lt;T,Integer&gt; putConsumer,</span><br><span class="hljs-params">    Consumer&lt;T&gt; printConsumer)</span>&#123;<br>    List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//得到数组返回的元素</span><br>    <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>    <span class="hljs-comment">//后面的Integer是返回结果</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>    <span class="hljs-comment">//根据数组长度来进行遍历，对值进行累加</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>        threadList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                putConsumer.accept(array, j%length);<br>            &#125;<br>        &#125;));<br>    &#125;<br>    threadList.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>    threadList.forEach(t -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 等所有线程结束</span><br>    printConsumer.accept(array);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>不安全的数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>     ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>     (array)-&gt;array.length,<br>     (array, index) -&gt; array[index]++,<br>     array-&gt; System.out.println(Arrays.toString(array))<br>);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[<span class="hljs-number">6794</span>, <span class="hljs-number">6687</span>, <span class="hljs-number">6664</span>, <span class="hljs-number">6587</span>, <span class="hljs-number">6576</span>, <span class="hljs-number">6491</span>, <span class="hljs-number">6480</span>, <span class="hljs-number">6530</span>, <span class="hljs-number">6536</span>, <span class="hljs-number">6740</span>]<br></code></pre></td></tr></table></figure><p><strong>安全的数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">demo(<br>    ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>    (arr)-&gt; arr.length(),<br>    (arr,index) -&gt; arr.getAndIncrement(index),<br>    (arr)-&gt;System.out.println(arr)<br>);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">[<span class="hljs-meta">10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000</span>]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子类之原子引用</title>
    <link href="/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8/"/>
    <url>/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>为什么需要原子引用类型？</strong></p><p>保证引用类型的共享变量是线程安全的。</p><p>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。</p><ul><li><p><code>AtomicReference</code>：引用类型原子类；</p></li><li><p><code>AtomicStampedRerence</code>：原子更新带有版本号的引用类型；</p><p>该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p></li><li><p><code>AtomicMarkableReference</code> ：原子更新带有标记的引用类型。</p><p>该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</p></li></ul><h3 id="二、取款示例"><a href="#二、取款示例" class="headerlink" title="二、取款示例"></a>二、取款示例</h3><blockquote><p>先做一个不使用 <strong>AtomicReference</strong> 取款的不安全实现</p></blockquote><ul><li><strong>取款案例</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/5</span><br><span class="hljs-comment"> * Description 取款案例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br><br>    <span class="hljs-comment">// 获取余额</span><br>    BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//取款</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法内会启动 1000 个线程，每个线程做 -10 元 的操作</span><br><span class="hljs-comment">     * 如果初始余额为 10000 那么正确的结果应当是 0</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(DecimalAccount account)</span>&#123;<br>        List&lt;Thread&gt; threadList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++)&#123;<br>            threadList.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                account.withdraw(BigDecimal.TEN);<br>            &#125;));<br>        &#125;<br>        threadList.forEach(Thread::start);<br>        threadList.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        System.out.println(account.getBalance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="不安全实现"><a href="#不安全实现" class="headerlink" title="不安全实现"></a>不安全实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/5</span><br><span class="hljs-comment"> * Description 不安全实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        DecimalAccount.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalAccountUnsafe</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10000&quot;</span>)));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span>&#123;<br>    BigDecimal balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountUnsafe</span><span class="hljs-params">(BigDecimal balance)</span>&#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBalance();<br>        <span class="hljs-comment">// 减法</span><br>        <span class="hljs-built_in">this</span>.balance = balance.subtract(amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">3850</span><br></code></pre></td></tr></table></figure><h4 id="安全实现-加锁"><a href="#安全实现-加锁" class="headerlink" title="安全实现-加锁"></a>安全实现-加锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/5</span><br><span class="hljs-comment"> * Description 安全实现-加锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        DecimalAccount.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalAccountSafeLock</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10000&quot;</span>)));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountSafeLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    BigDecimal balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountSafeLock</span><span class="hljs-params">(BigDecimal balance)</span>&#123;<br>        <span class="hljs-built_in">this</span>.balance = balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBalance();<br>            <span class="hljs-built_in">this</span>.balance = balance.subtract(amount);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">0<br></code></pre></td></tr></table></figure><h4 id="安全实现-CAS"><a href="#安全实现-CAS" class="headerlink" title="安全实现-CAS"></a>安全实现-CAS</h4><p>在<code>AtomicReference</code>类中，存在一个value类型的变量，保存对<code>BigDecimal</code>对象的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigDecimal;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/6</span><br><span class="hljs-comment"> * Description 安全实现-CAS</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        DecimalAccount.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DecimalAccountSafeCas</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigDecimal</span>(<span class="hljs-string">&quot;10000&quot;</span>)));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountSafeCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br><br>    AtomicReference&lt;BigDecimal&gt; reference;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountSafeCas</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br>        reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> reference.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> reference.get();<br>            <span class="hljs-comment">// 注意：这里的balance返回的是一个新的对象，即 pre!=next</span><br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (reference.compareAndSet(prev,next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">0<br></code></pre></td></tr></table></figure><h3 id="三、ABA-问题"><a href="#三、ABA-问题" class="headerlink" title="三、ABA 问题"></a>三、ABA 问题</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><h4 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/6</span><br><span class="hljs-comment"> * Description ABA问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test07&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test07</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">//获取值A</span><br>        <span class="hljs-comment">//这个共享变量被其它线程修改过?</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> reference.get();<br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//尝试改为C</span><br>        log.debug(<span class="hljs-string">&quot;change A -&gt; C &#123;&#125;&quot;</span>,reference.compareAndSet(prev,<span class="hljs-string">&quot;C&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A -&gt; B &#123;&#125;&quot;</span>,reference.compareAndSet(reference.get(),<span class="hljs-string">&quot;B&quot;</span>));<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">0.5</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change B -&gt; A &#123;&#125;&quot;</span>,reference.compareAndSet(reference.get(),<span class="hljs-string">&quot;A&quot;</span>));<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">35.527</span> [main] DEBUG c.Test07 - main start...<br><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">35.582</span> [t1] DEBUG c.Test07 - change A <span class="hljs-punctuation">-&gt;</span> B <span class="hljs-literal">true</span><br><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">36.084</span> [t2] DEBUG c.Test07 - change B <span class="hljs-punctuation">-&gt;</span> A <span class="hljs-literal">true</span><br><span class="hljs-number">16</span>:<span class="hljs-number">04</span>:<span class="hljs-number">37.084</span> [main] DEBUG c.Test07 - change A <span class="hljs-punctuation">-&gt;</span> C <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>主线程仅能判断出共享变量的值与最初值 A 是否相同，不能感知到这种从 A 改为 B 又改回 A 的情况。</p><p>如果主线程希望, 只要有其它线程变动过共享变量，那么自己的 cas 就算失败，这时，需要再加一个版本号。</p><h3 id="四、ABA问题解决"><a href="#四、ABA问题解决" class="headerlink" title="四、ABA问题解决"></a>四、ABA问题解决</h3><h4 id="4-1-AtomicStampedReference"><a href="#4-1-AtomicStampedReference" class="headerlink" title="4.1 AtomicStampedReference"></a>4.1 AtomicStampedReference</h4><p>Java提供了<code>AtomicStampedReference</code>来解决。<code>AtomicStampedReference</code>通过包装<code>[E,Integer]</code>的元组来对对象标记版本戳stamp，从而避免ABA问题。</p><p>AtomicStampedReference的compareAndSet()方法定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V   expectedReference,</span><br><span class="hljs-params">                             V   newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><ul><li>expectedReference：预期引用；</li><li>newReference：更新后的引用；</li><li>expectedStamp：预期标志；</li><li>newStamp：更新后的标志。</li></ul><p>如果更新后的引用和标志和当前的引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。</p><p>Pair为<code>AtomicStampedReference</code>的内部类，主要用于记录引用和版本戳信息（标识），定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">final</span> T reference;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> stamp;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T reference, <span class="hljs-type">int</span> stamp)</span> &#123;<br>        <span class="hljs-built_in">this</span>.reference = reference;<br>        <span class="hljs-built_in">this</span>.stamp = stamp;<br>    &#125;<br>    <span class="hljs-keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(T reference, <span class="hljs-type">int</span> stamp)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;T&gt;(reference, stamp);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Pair&lt;V&gt; pair;<br></code></pre></td></tr></table></figure><p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增。</p><p>同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。在<code>AtomicStampedReference</code>中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象，然后赋值给变量pair。</p><p><strong>如set方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V newReference, <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">if</span> (newReference != current.reference || newStamp != current.stamp)<br>        <span class="hljs-built_in">this</span>.pair = Pair.of(newReference, newStamp);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-使用AtomicStampedReference解决ABA问题"><a href="#4-2-使用AtomicStampedReference解决ABA问题" class="headerlink" title="4.2 使用AtomicStampedReference解决ABA问题"></a>4.2 使用AtomicStampedReference解决ABA问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/6</span><br><span class="hljs-comment"> * Description AtomicStampedReference</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test08&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test08</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt;  reference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">//获取值 A</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> reference.getReference();<br>        <span class="hljs-comment">// 获取版本号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> reference.getStamp();<br>        log.debug(<span class="hljs-string">&quot;版本&#123;&#125;&quot;</span>,stamp);<br>        <span class="hljs-comment">// 如果中间有其它线程干扰,发生了ABA现象</span><br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, reference.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, reference.compareAndSet(reference.getReference(), <span class="hljs-string">&quot;B&quot;</span>, reference.getStamp(), reference.getStamp() + <span class="hljs-number">1</span>));<br>            log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, reference.getStamp());<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, reference.compareAndSet(reference.getReference(), <span class="hljs-string">&quot;A&quot;</span>, reference.getStamp(), reference.getStamp() + <span class="hljs-number">1</span>));<br>            log.debug(<span class="hljs-string">&quot;更新版本为 &#123;&#125;&quot;</span>, reference.getStamp());<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">16:36:35.347 [main] DEBUG c.Test08 - main start...</span><br><span class="hljs-section">16:36:35.349 [main] DEBUG c.Test08 - 版本0</span><br><span class="hljs-section">16:36:35.403 [t1] DEBUG c.Test08 - change A-&gt;B true</span><br><span class="hljs-section">16:36:35.404 [t1] DEBUG c.Test08 - 更新版本为 1</span><br><span class="hljs-section">16:36:35.905 [t2] DEBUG c.Test08 - change B-&gt;A true</span><br><span class="hljs-section">16:36:35.905 [t2] DEBUG c.Test08 - 更新版本为 2</span><br><span class="hljs-section">16:36:36.905 [main] DEBUG c.Test08 - change A-&gt;C false</span><br></code></pre></td></tr></table></figure><p><strong>分析</strong></p><p>main线程最初的版本号是0，main线程在修改值之前，已经被其他线程修改了2个版本，等到main线程修改时发现版本号不一致了，所以修改值失败。</p><p><strong>AtomicStampedReference</strong> 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： <strong>A -&gt; B -&gt; A -&gt; C</strong> ，通过<strong>AtomicStampedReference</strong>，我们可以知道，引用变量中途被更改了几次。</p><h4 id="4-3-AtomicMarkableReference解决ABA问题"><a href="#4-3-AtomicMarkableReference解决ABA问题" class="headerlink" title="4.3 AtomicMarkableReference解决ABA问题"></a>4.3 AtomicMarkableReference解决ABA问题</h4><p>有时候，并不关心引用变量更改了几次，只是单纯的关心<strong>是否更改过</strong>，所以就有了 <code>AtomicMarkableReference</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicMarkableReference;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/6</span><br><span class="hljs-comment"> * Description AtomicMarkableReference解决ABA问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TestAtomicMarkableReference&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAtomicMarkableReference</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicMarkableReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>        <span class="hljs-comment">// 获取值 A</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>        log.debug(<span class="hljs-string">&quot;是否被改过 &#123;&#125;&quot;</span>, ref.isMarked());<br>        <span class="hljs-comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span><br>        other();<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 尝试改为 C</span><br>        log.debug(<span class="hljs-string">&quot;能否 change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">other</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;change A-&gt;B &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>));<br>            log.debug(<span class="hljs-string">&quot;修改A-&gt;B &#123;&#125;&quot;</span>, ref.isMarked());<br>            log.debug(<span class="hljs-string">&quot;change B-&gt;A &#123;&#125;&quot;</span>, ref.compareAndSet(ref.getReference(), <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>));<br>            log.debug(<span class="hljs-string">&quot;修改B-&gt;A &#123;&#125;&quot;</span>, ref.isMarked());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">25.278</span> [main] DEBUG c.TestAtomicMarkableReference - main start...<br><span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">25.280</span> [main] DEBUG c.TestAtomicMarkableReference - 是否被改过 <span class="hljs-literal">false</span><br><span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">25.336</span> [t1] DEBUG c.TestAtomicMarkableReference - change A-&gt;B <span class="hljs-literal">true</span><br><span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">25.337</span> [t1] DEBUG c.TestAtomicMarkableReference - 修改A-&gt;B <span class="hljs-literal">true</span><br><span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">25.337</span> [t1] DEBUG c.TestAtomicMarkableReference - change B-&gt;A <span class="hljs-literal">true</span><br><span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">25.337</span> [t1] DEBUG c.TestAtomicMarkableReference - 修改B-&gt;A <span class="hljs-literal">true</span><br><span class="hljs-number">16</span>:<span class="hljs-number">40</span>:<span class="hljs-number">26.337</span> [main] DEBUG c.TestAtomicMarkableReference - 能否 change A-&gt;C <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原子类之AtomicInteger</title>
    <link href="/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8BAtomicInteger/"/>
    <url>/2023/03/29/%E5%8E%9F%E5%AD%90%E7%B1%BB%E4%B9%8BAtomicInteger/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>AtomicInteger 类底层存储一个int值，并提供方法对该int值进行原子操作。AtomicInteger 作为<code>java.util.concurrent.atomic</code>包的一部分，从Java 1.5开始引入。</p><p>接下来我们先从三个问题入手，对AtomicInteger概念有一个基本的了解。</p><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>（1）什么是原子操作呢？</strong></p><p>所谓原子操作，就是一个独立且不可分割的操作。AtomicInteger 工具类提供了对整数操作的原子封装。</p><p><strong>（2）为什么要对整数操作进行原子封装呢？</strong></p><p>在 java 中，当我们在多线程情况下，对一个整型变量做加减操作时，如果不加任何的多线程并发控制，大概率会出现线程安全问题，也就是说当多线程同时操作一个整型变量的增减时，会出现运算结果错误的问题。AtomicInteger 工具类就是为了<strong>简化整型变量的同步处理</strong>而诞生的。</p><p><strong>（3）什么场景下需要使用AtomicInteger？</strong></p><ul><li>多线程并发场景下操作一个计数器，需要保证计数器操作的原子性。</li><li>进行数值比较，如果给定值与当前值相等，进行数值的更新操作，并实现操作的非阻塞算法。</li></ul><h3 id="二、AtomicInteger基础用法"><a href="#二、AtomicInteger基础用法" class="headerlink" title="二、AtomicInteger基础用法"></a>二、AtomicInteger基础用法</h3><p>通过<code>AtomicInteger</code>构造方法，可以创建一个<code>AtomicInteger</code>对象，该对象的初始值默认为0。<code>AtomicInteger</code>提供get和set方法，获取底层int整数值，与设置int整数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/5</span><br><span class="hljs-comment"> * Description AtomicInteger基本用法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//首先创建一个AtomicInteger对象</span><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>        <span class="hljs-comment">//在操作之前先赋值,如果不显示赋值则默认为0,就像 int 型变量使用前做初始化赋值一样。</span><br>        atomicInteger.set(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">// 之后可以调用各种方法进行增减操作</span><br>        <span class="hljs-comment">// 获取当前值</span><br>        System.out.println(atomicInteger.get());<br>        <span class="hljs-comment">// 先获取当前值，之后再对原值加100,返回之前的旧值</span><br>        System.out.println(atomicInteger.getAndAdd(<span class="hljs-number">100</span>));<br>        <span class="hljs-comment">// 先获取当前值，之后再对原值减1,返回旧值</span><br>        System.out.println(atomicInteger.getAndDecrement());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs undefined">100<br>100<br>200<br></code></pre></td></tr></table></figure><h3 id="三、原子计数器场景"><a href="#三、原子计数器场景" class="headerlink" title="三、原子计数器场景"></a>三、原子计数器场景</h3><p>把<code>AtomicInteger</code>作为一个计数器使用，<code>AtomicInteger</code>提供了若干方法进行加法、减法的原子操作。</p><blockquote><p>比如从一个map里面获取值，用get()方法，这是第一个操作；</p><p>获取到值之后给这个值加上n，这是第二个操作；</p><p>将进行过加法运算的值，再次放入map里面是第三个操作。</p></blockquote><p>所谓操作的原子性是指：在多线程并发的场景下，上面的三个操作是原子性的，也就是不可分割的。</p><p>不会出现A线程get了数值，B线程同时也get到了该数值，两个线程同时为该值做运算并先后再次放入的情况，这种情况对于<code>AtomicInteger</code>而言是不会出现的，<code>AtomicInteger</code>操作是线程安全的、不可分割的。</p><p><strong>AtomicInteger相关方法</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>addAndGet()</td><td>将给定的值加到当前值上，并在加法后返回新值，并保证操作的原子性。</td></tr><tr><td>getAndAdd()</td><td>将给定的值加到当前值上，并返回旧值，并保证操作的原子性。</td></tr><tr><td>incrementAndGet()</td><td>将当前值增加1，并在增加后返回新值。它相当于<code>++i</code>操作，并保证操作的原子性。</td></tr><tr><td>getAndIncrement()</td><td>将当前值增加1并返回旧值。相当于<code>i++</code>操作，并保证操作的原子性。</td></tr><tr><td>decrementAndGet()</td><td>将当前值减去1，并在减去后返回新值，相当于<code>--i</code>操作，并保证操作的原子性。</td></tr><tr><td>getAndDecrement()</td><td>将当前值减去1，并返回旧值。它相当于 <code>i--</code>操作，并保证操作的原子性。</td></tr></tbody></table><p><strong>使用示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/5</span><br><span class="hljs-comment"> * Description  AtomicInteger示例操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span><br>        System.out.println(i.getAndIncrement());<br><br>        <span class="hljs-comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span><br>        System.out.println(i.incrementAndGet());<br><br>        <span class="hljs-comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span><br>        System.out.println(i.decrementAndGet());<br><br>        <span class="hljs-comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span><br>        System.out.println(i.getAndDecrement());<br><br>        <span class="hljs-comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span><br>        System.out.println(i.getAndAdd(<span class="hljs-number">5</span>));<br><br>        <span class="hljs-comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span><br>        System.out.println(i.addAndGet(-<span class="hljs-number">5</span>));<br><br>        <span class="hljs-comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span><br>        <span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>        System.out.println(i.getAndUpdate(p -&gt; p - <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span><br>        <span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>        System.out.println(i.updateAndGet(p -&gt; p + <span class="hljs-number">2</span>));<br><br>        <span class="hljs-comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span><br>        <span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>        <span class="hljs-comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span><br>        <span class="hljs-comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span><br>        System.out.println(i.getAndAccumulate(<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br><br>        <span class="hljs-comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span><br>        <span class="hljs-comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span><br>        System.out.println(i.accumulateAndGet(-<span class="hljs-number">10</span>, (p, x) -&gt; p + x));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、数值比对及交换操作"><a href="#四、数值比对及交换操作" class="headerlink" title="四、数值比对及交换操作"></a>四、数值比对及交换操作</h3><p>compareAndSet操作将一个内存位置的内容与一个给定的值进行比较，只有当它们相同时，才会将该内存位置的内容修改为一个给定的新值。这个过程是以单个原子操作的方式完成的。</p><p><strong>语法</strong></p><ul><li><strong>compareAndSet方法</strong>：如果<code>当前值==预期值</code>，则将值设置为给定的更新值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span><br></code></pre></td></tr></table></figure><ul><li><code>expect</code>是预期值</li><li><code>update</code>是更新值</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/11/5</span><br><span class="hljs-comment"> * Description  compareAndSet() 方法示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//初始值为100的atomic Integer</span><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-comment">//当前值100 = 预期值100，所以设置atomicInteger=110</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">110</span>);<br>        System.out.println(isSuccess);      <span class="hljs-comment">//输出结果为true表示操作成功</span><br><br>        <span class="hljs-comment">//当前值110 = 预期值100? 不相等，所以atomicInteger仍然等于110</span><br>        isSuccess = atomicInteger.compareAndSet(<span class="hljs-number">100</span>,<span class="hljs-number">120</span>);<br>        System.out.println(isSuccess);      <span class="hljs-comment">//输出结果为false表示操作失败</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-literal">true</span><br><span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>AtomicInteger</code>可以帮助我们在不使用synchronized同步锁的情况下，实现在多线程场景下int数值操作的线程安全，操作的原子性。并且使用<code>AtomicInteger</code>来实现int数值的原子操作，远比使用synchronized同步锁效率更高。</p><p><code>java.util.concurrent.atomic</code>包不仅提供了<code>AtomicInteger</code>，还提供了AtomicBoolean布尔原子操作类、AtomicLong长整型布尔原子操作类、AtomicReference对象原子操作类、AtomicIntegerArray整型数组原子操作类、AtomicLongArray长整型数组原子操作类、AtomicReferenceArray对象数组原子操作类。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS</title>
    <link href="/2023/03/29/CAS/"/>
    <url>/2023/03/29/CAS/</url>
    
    <content type="html"><![CDATA[<h3 id="一、案例分析"><a href="#一、案例分析" class="headerlink" title="一、案例分析"></a>一、案例分析</h3><blockquote><p>在一个银行转账的案例中，100个线程对1000元的账户每个转出账10元，理论上最后账户剩下余额为0元，但是如果不加锁，会出现线程安全问题；</p><p>解决方法：</p><p>1.可以使用sync锁进行加锁操作，但是效率太低；</p><p>2.通过cas无锁优化，接下来具体来讲解一下cas</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br><br>        <span class="hljs-comment">// 需要不断尝试，直到成功为止</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 比如拿到了旧值 1000</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-comment">// 在这个基础上 1000-10 = 990</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br><br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><p>compareAndSet 在 set 前，先比较 prev 与当前值,不一致了，next 作废，返回 false 表示失败。</p><p>比如，别的线程已经做了减法，当前值已经被减成了990那么本线程的这次 990 就作废了，进入 while 下次循环重试一致，以 next 设置为新值，返回 true 表示成功。</p><p>其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 的说法），它必须是原子操作。</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329154129427.png" alt="image-20230329154129427"></p><p><strong>上述图解</strong></p><p>线程1从 Account 对象中<strong>获取余额100</strong>，并执行 <code>-10</code> 操作，但此时线程2已经将余额修改为 90 了，线程1 执行 <code>compareAndSet(100,90)</code> 方法时，发现自己拿到的最新值 100 与 Account 共享变量上的最新结果 90 对比，发现不一致，因此这次 CAS 操作失败返回 false，再次进入循环。</p><p><strong>核心的思想就是采用不断尝试直至成功的方式来保护共享变量的线程安全。</strong></p><p><strong>注意</strong>:</p><ul><li>其实 CAS 的底层是 lock cmpxchg指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</li><li>在多核状态下，某个核执行到带lock的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</li></ul><h4 id="慢动作分析"><a href="#慢动作分析" class="headerlink" title="慢动作分析"></a>慢动作分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.thread.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-11-03</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 慢动作分析</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.SlowMotion&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SlowMotion</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">balance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">10000</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mainPrev</span> <span class="hljs-operator">=</span> balance.get();<br>        log.debug(<span class="hljs-string">&quot;try get &#123;&#125;&quot;</span>,mainPrev);<br><br>        <span class="hljs-comment">//线程1 修改</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            sleep(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            balance.compareAndSet(prev,<span class="hljs-number">9000</span>);<br>            log.debug(balance.toString());<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;try set 8000...&quot;</span>);<br><br>        <span class="hljs-comment">//主线程修改</span><br>        <span class="hljs-comment">//此时balance的值已经改为9000,cas失败</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> balance.compareAndSet(mainPrev, <span class="hljs-number">8000</span>);<br>        log.debug(<span class="hljs-string">&quot;is success?&#123;&#125;&quot;</span>,isSuccess);<br>        <span class="hljs-keyword">if</span>(!isSuccess) &#123;<br>            <span class="hljs-comment">//AtomicInteger内接收数值的变量用voltile修饰，每次都能获取到最新值</span><br>            mainPrev = balance.get();<span class="hljs-comment">//9000</span><br>            log.debug(<span class="hljs-string">&quot;try set 8000...&quot;</span>);<br>            isSuccess = balance.compareAndSet(mainPrev, <span class="hljs-number">8000</span>);<br>            log.debug(<span class="hljs-string">&quot;is success ? &#123;&#125;&quot;</span>, isSuccess);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">17.068</span> c.SlowMotion [main] - <span class="hljs-keyword">try</span> <span class="hljs-keyword">get</span> <span class="hljs-number">10000</span><br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">18.097</span> c.SlowMotion [t1] - <span class="hljs-number">9000</span><br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">19.100</span> c.SlowMotion [main] - <span class="hljs-keyword">try</span> <span class="hljs-keyword">set</span> <span class="hljs-number">8000.</span>..<br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">19.100</span> c.SlowMotion [main] - <span class="hljs-keyword">is</span> success?<span class="hljs-literal">false</span><br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">19.100</span> c.SlowMotion [main] - <span class="hljs-keyword">try</span> <span class="hljs-keyword">set</span> <span class="hljs-number">8000.</span>..<br><span class="hljs-number">18</span>:<span class="hljs-number">42</span>:<span class="hljs-number">19.100</span> c.SlowMotion [main] - <span class="hljs-keyword">is</span> success ? <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="二、volatile"><a href="#二、volatile" class="headerlink" title="二、volatile"></a>二、volatile</h3><p>获取共享变量时，<strong>为了保证该变量的可见性，需要使用 volatile 修饰</strong>。它可以用来修饰成员变量和静态成员变量，可以避免线程从自己的工作缓存中查找变量的值，而是必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。<br><em>注意：volatile 仅仅保证了共享变量的可见性，让其他线程能够看到最新值，但不能解决指令交错问题（不能保证原子性）</em></p><p>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果。</p><h4 id="CAS的特点"><a href="#CAS的特点" class="headerlink" title="CAS的特点"></a>CAS的特点</h4><p><strong>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</strong></p><ul><li>CAS 是基于乐观锁的思想：最乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再重试呗。</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想改，我改完了解开锁，你们才有机会。</li><li>CAS 体现的是无锁并发、无阻塞并发，因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一，但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响。</li></ul><h3 id="三、为什么无锁效率高"><a href="#三、为什么无锁效率高" class="headerlink" title="三、为什么无锁效率高"></a>三、为什么无锁效率高</h3><ul><li><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而synchronized 会让线程在没有获得锁的时候，发生上下文切换，进入阻塞。</p><p>打个比喻线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火，等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大。</p></li><li><p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还是会导致上下文切换。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>happens-before规则</title>
    <link href="/2023/03/29/happens-before%E8%A7%84%E5%88%99/"/>
    <url>/2023/03/29/happens-before%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Happens-Before规则主要有两个作用：</p><ul><li>一是解决数据竞争问题；</li><li>二是为开发人员提供足够强的内存可见性。</li></ul><h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><h4 id="1-1-数据竞争"><a href="#1-1-数据竞争" class="headerlink" title="1.1 数据竞争"></a>1.1 数据竞争</h4><p><strong>数据竞争就是指并发条件下的状态属性不同步而引发的读写不一致问题</strong>。</p><p>现假设有两个线程A、B要对内存中的同一个变量进行访问，线程A要对这个变量执行写操作，线程B要对这个变量执行读操作，两个操作是同时进行的，此时若不加以限制，线程B读操作所得到的结果就有两种可能，且结果是不可预测的，这并不是开发人员希望看到的结果，在JMM（Java内存模型）设计之初就考虑到了这个问题，必须人为的指定读&#x2F;写操作的执行顺序，Happens-Before规则应运而生。</p><h4 id="1-2-重排序"><a href="#1-2-重排序" class="headerlink" title="1.2 重排序"></a>1.2 重排序</h4><p><strong>重排序就是指实际应用中，编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段</strong>。</p><p>在JMM中，对于重排序采取了如下策略：</p><ul><li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li><li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（允许）。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329145617670.png" alt="image-20230329145617670"></p><h3 id="二、Happens-Before规则"><a href="#二、Happens-Before规则" class="headerlink" title="二、Happens-Before规则"></a>二、Happens-Before规则</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p><strong>Happens-Before规则在JRS-133中定义如下：</strong></p><ul><li><strong>定义一</strong>：如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li><strong>定义二</strong>：两个操作间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ul><p>定义1向开发人员保证如果操作A happens-before 操作B，那么操作A的结果将对操作B可见，且操作A的执行顺序在操作B之前。</p><p>定义2对编译器和处理器进行约束，重排序必须在不改变程序执行结果（单线程条件下）的前提下进行。</p><h4 id="2-2-具体规则"><a href="#2-2-具体规则" class="headerlink" title="2.2 具体规则"></a>2.2 具体规则</h4><p>Happens-Before规则共包含以下八条，程序执行时会严格按照规则进行。</p><ul><li><strong>程序顺序规则</strong>：如果程序中操作A在操作B之前，那么在线程中A操作将在B操作之前执行。</li><li><strong>监视器锁规则</strong>：在监视器锁上的解锁操作必须在同一个监视器锁上的加锁操作之前执行。</li><li><strong>volatile变量规则</strong>：对volatile变量的写入操作必须在对该变量的读操作之前执行。</li><li><strong>线程启动规则</strong>：在线程上对Thread.Start的调用必须在该线程中执行的任何操作之前执行。</li><li><strong>线程结束规则</strong>：线程中的任何操作都必须在其他线程检测到该线程已经结束之前执行，或者从Thread.join中成功返回，或者在调用Thread.isAlive时返回false。</li><li><strong>中断规则</strong>：当一个线程在另一个线程上调用interrupt时，必须在被中断线程检测到interrupt调用之前执行（通过抛出InterruptedException，或者调用isInterrupted和interrupted）。</li><li><strong>终结器规则</strong>：对象的构造函数必须在启动该对象的终结器之前执行完成。</li><li><strong>传递性</strong>：如果操作A在操作B之前执行，并且操作B在操作C之前执行，那么操作A必须在操作C之前执行。</li></ul><p>在 Java 语言里面，Happens-Before 的语义本质上是一种可见性，<code>A Happens-Before B</code> 意味着 A 事件对 B 事件来说是可见的，无论 A 事件和 B 事件是否发生在同一个线程里。例如 A 事件发生在线程 1 上，B 事件发生在线程 2 上，Happens-Before 规则保证线程 2 上也能看到 A 事件的发生。</p><p>简而言之，<strong>happens-before 向我们保证了在多线程环境中，上一个操作对下一个操作的有序性和操作结果的可见性。</strong></p><h3 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h3><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        x = <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-keyword">synchronized</span>(m) &#123;<br>        System.out.println(x);<br>    &#125;<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><ul><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p>说明：volatile修饰的变量, 通过写屏障, 共享到主存中, 其他线程通过读屏障, 读取主存的数据。</p><ul><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br>x = <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    System.out.println(x);<br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：线程还没启动时, 修改变量的值, 在启动线程后, 获取的变量值, 肯定是修改过的。</p><ul><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    x = <span class="hljs-number">10</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br>t1.join();<br>System.out.println(x);<br></code></pre></td></tr></table></figure><p><strong>说明</strong>：主线程获取的x值, 是线程执行完对x的写操作之后的值。</p><ul><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过 t2.interrupted 或 t2.isInterrupted）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(x);    <span class="hljs-comment">// 10, 打断了, 读取的也是打断前修改的值</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start();<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>        sleep(<span class="hljs-number">1</span>);<br>        x = <span class="hljs-number">10</span>;<br>        t2.interrupt();<br>    &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>    <span class="hljs-keyword">while</span>(!t2.isInterrupted()) &#123;<br>        Thread.<span class="hljs-keyword">yield</span>();<br>    &#125;<br>    System.out.println(x); <span class="hljs-comment">// 10</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li><li>具有传递性，如果 <code>x hb-&gt; y</code> 并且 <code>y hb-&gt; z</code> 那么有 <code>x hb-&gt; z</code> ，配合 volatile 的防指令重排，有下面的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> x;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> y;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123; <br>    y = <span class="hljs-number">10</span>;<br>    x = <span class="hljs-number">20</span>;<br>&#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>    <span class="hljs-comment">// x=20 对 t2 可见, 同时 y=10 也对 t2 可见</span><br>    System.out.println(x); <br>&#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><p>因为x加了volatile, 所以在<code>volatile static int x</code> 代码的上面添加了读屏障, 保证读到的x和y的变化是可见的(包括y, 只要是读屏障下面都可以); 通过传递性, t2线程对x,y的写操作, 都是可见的。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发编程解决单例模式</title>
    <link href="/2023/03/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/03/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%A7%A3%E5%86%B3%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p><strong>定义：如果一个类始终只能创建一个实例，那么这个类被称为单例类，这种设计模式被称为单例模式。</strong></p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时<strong>确保只有单个对象被创建</strong>。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><p>注意：</p><ol><li>单例类<strong>只能有一个实例</strong>。</li><li>单例类必须<strong>自己创建自己的</strong>唯一实例。</li><li>单例类必须<strong>给所有其他对象提供</strong>这一实例。</li></ol><blockquote><p>关于具体的单例模式，可以参考我写的这篇文章：<a href="https://www.yuque.com/weiyikai/java/yh0hkfdvft2ok6kl">单例模式</a></p></blockquote><h3 id="二、懒汉式单例"><a href="#二、懒汉式单例" class="headerlink" title="二、懒汉式单例"></a>二、懒汉式单例</h3><p>为了在多线程环境下保护懒汉式，需要加上 synchronized 锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><p>多线程同时调用<code>getInstance()</code>, 如果不加synchronized锁, 此时两个线程同时判断INSTANCE为空, 此时都会<code>new Singleton()</code>, 此时就不再符合单例模式。所以要加锁,防止多线程操作共享资源造成的安全问题。</p><p>同时，上面代码的效率也存在很大问题，当成功创建一个单例对象后，又来一个线程在执行获取锁时，还是会加锁，再次进行判断<code>INSTANCE==null</code>，此时<code>INSTANCE</code>肯定不为null,然后就返回刚才创建的INSTANCE。这样做会严重影响性能。</p><h4 id="双重检查锁优化"><a href="#双重检查锁优化" class="headerlink" title="双重检查锁优化"></a>双重检查锁优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t2</span><br>            <span class="hljs-comment">// 首次访问会同步，而之后的使用没有 synchronized</span><br>            <span class="hljs-keyword">synchronized</span>(Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>以上的实现特点是</strong></p><ul><li>懒惰实例化</li><li>首次使用 <code>getInstance()</code> 才使用 synchronized 加锁，后续使用时无需加锁</li><li>有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外</li></ul><h3 id="三、代码存在的问题"><a href="#三、代码存在的问题" class="headerlink" title="三、代码存在的问题"></a>三、代码存在的问题</h3><p>但在多线程环境下，上面的代码是有问题的，<code>getInstance</code> 方法对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span> <span class="hljs-comment">// 判断是否为空</span><br><span class="hljs-comment">// ldc是获得类对象</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-comment">// 复制操作数栈栈顶的值放入栈顶, 将类对象的引用地址复制了一份</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-comment">// 操作数栈栈顶的值弹出，即将对象的引用地址存到局部变量表中</span><br><span class="hljs-comment">// 将类对象的引用地址存储了一份，是为了将来解锁用</span><br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter<br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-comment">// 新建一个实例</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-comment">// 复制了一个实例的引用</span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-comment">// 通过这个复制的引用调用它的构造方法</span><br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-comment">// 最开始的这个引用用来进行赋值操作</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p>其中</p><ul><li>17 表示创建对象，将对象引用入栈 &#x2F;&#x2F; new Singleton</li><li>20 表示复制一份对象引用 &#x2F;&#x2F; 引用地址</li><li>21 表示利用一个对象引用，调用构造方法</li><li>24 表示利用一个对象引用，赋值给 static INSTANCE</li></ul><p>也许 jvm 会优化为：先执行 24，再执行 21。</p><p>如果两个线程 t1，t2 按如下时间序列执行：</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329142528659.png" alt="image-20230329142528659"></p><ul><li>关键在于 0: getstatic 这行代码在 monitor 控制之外，可以越过 monitor 读取 INSTANCE 变量的值</li><li>这时 t1 还未完全将构造方法执行完毕，如果在构造方法中要执行很多初始化操作，那么 t2 拿到的是将是一个未初始化完毕的单例 对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排。</li><li>注意在 JDK 5 以上的版本的 volatile 才会真正有效</li></ul><h3 id="四、volatile解决方案"><a href="#四、volatile解决方案" class="headerlink" title="四、volatile解决方案"></a>四、volatile解决方案</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实例没创建，才会进入内部的 synchronized代码块</span><br>        <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123; <span class="hljs-comment">// t2</span><br>                <span class="hljs-comment">// 也许有其它线程已经创建实例，所以再判断一次</span><br>                <span class="hljs-keyword">if</span> (INSTANCE == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// t1</span><br>                    INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字节码上看不出来 volatile 指令的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br><span class="hljs-number">0</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">3</span>: ifnonnull <span class="hljs-number">37</span><br><span class="hljs-number">6</span>: ldc #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">8</span>: dup<br><span class="hljs-number">9</span>: astore_0<br><span class="hljs-number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性<br><span class="hljs-number">11</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">14</span>: ifnonnull <span class="hljs-number">27</span><br><span class="hljs-number">17</span>: <span class="hljs-keyword">new</span> #<span class="hljs-number">3</span> <span class="hljs-comment">// class cn/itcast/n5/Singleton</span><br><span class="hljs-number">20</span>: dup<br><span class="hljs-number">21</span>: invokespecial #<span class="hljs-number">4</span> <span class="hljs-comment">// Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="hljs-number">24</span>: putstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-comment">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="hljs-number">27</span>: aload_0<br><span class="hljs-number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性<br><span class="hljs-number">29</span>: goto <span class="hljs-number">37</span><br><span class="hljs-number">32</span>: astore_1<br><span class="hljs-number">33</span>: aload_0<br><span class="hljs-number">34</span>: monitorexit<br><span class="hljs-number">35</span>: aload_1<br><span class="hljs-number">36</span>: athrow<br><span class="hljs-number">37</span>: getstatic #<span class="hljs-number">2</span> <span class="hljs-comment">// Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="hljs-number">40</span>: areturn<br></code></pre></td></tr></table></figure><p>如上面的注释内容所示，读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p><ul><li>可见性<ul><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>而读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ul></li><li>有序性<ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul></li><li>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</li></ul><p>加上<code>volatile</code>之后, 保证了<code>指令的有序性</code>, 不会发生指令重排, 21就不会跑到24之后执行了</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/image-20230329142640768.png" alt="image-20230329142640768"></p><ul><li>synchronized 既能保证原子性、可见性、有序性，其中有序性是在该共享变量完全被synchronized 所接管（包括共享变量的读写操作），上面的例子中synchronized 外面的 if (INSTANCE &#x3D;&#x3D; null) 中的INSTANCE读操作没有被synchronized 接管，因此无法保证INSTANCE共享变量的有序性（即不能防止指令重排）。</li><li>对共享变量加volatile关键字可以保证可见性和有序性，但是不能保证原子性（即不能防止指令交错）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>volatile原理</title>
    <link href="/2023/03/28/volatile%E5%8E%9F%E7%90%86/"/>
    <url>/2023/03/28/volatile%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、内存屏障"><a href="#一、内存屏障" class="headerlink" title="一、内存屏障"></a>一、内存屏障</h3><p>内存屏障(Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：</p><ul><li>一是保证特定操作的执行顺序；</li><li>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。</li></ul><p>由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说*<u><strong>通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化</strong></u>*。</p><p>Memory Barrier的另外一个作用是*<u><strong>强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本</strong></u><em>。总之，</em><u><strong>volatile变量正是通过内存屏障（lock指令）实现其在内存中的语义，即可见性和禁止重排优化</strong></u>*。</p><h3 id="二、volatile的内存语义实现"><a href="#二、volatile的内存语义实现" class="headerlink" title="二、volatile的内存语义实现"></a>二、volatile的内存语义实现</h3><h4 id="2-1-volatile-重排序规则"><a href="#2-1-volatile-重排序规则" class="headerlink" title="2.1 volatile 重排序规则"></a>2.1 volatile 重排序规则</h4><p>为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。</p><p>为了实现 volatile 的内存语义，JMM 会限制特定类型的编译器和处理器重排序，JMM 会针对编译器制定 volatile 重排序规则表：</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232703364.png" alt="image-20230328232703364"></p><p><strong>说明</strong></p><ul><li>举例来说，第三行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。</li></ul><p><strong>图表分析</strong></p><ul><li>当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li><li>当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li><li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li></ul><h4 id="2-2-内存屏障指令"><a href="#2-2-内存屏障指令" class="headerlink" title="2.2 内存屏障指令"></a>2.2 内存屏障指令</h4><p>硬件层面的<strong>内存屏障</strong>（了解即可）：</p><ul><li><strong>sfence</strong>：即写屏障(Store Barrier)，在写指令之后插入写屏障，能让写入缓存的最新数据写回到主内存，以保证写入的数据立刻对其他线程可见。</li><li><strong>lfence</strong>：即读屏障(Load Barrier)，在读指令前插入读屏障，可以让高速缓存中的数据失效，重新从主内存加载数据，以保证读取的是最新的数据。</li><li><strong>mfence</strong>：即全能屏障(modify&#x2F;mix Barrier )，兼具sfence和lfence的功能。</li><li><strong>lock 前缀</strong>：lock不是内存屏障，而是一种锁。执行时会锁住内存子系统来确保执行顺序，甚至跨多个CPU。</li></ul><p>JMM层面的<strong>内存屏障</strong>：</p><ul><li><strong>loadload</strong>：读读，该屏障用来禁止处理器把上面的volatile读与下面的普通读重排序；</li><li><strong>storestore</strong>：写写，该屏障可以保证在volatile写之前，其前面的所有普通写操作都已经刷新到主内存中；</li><li><strong>loadstore</strong>：读写，该屏障用来禁止处理器把上面的volatile读与下面的普通写重排序；</li><li><strong>storeload</strong>：写读，该屏障的作用是避免volatile与后面可能有的volatile读&#x2F;写操作重排序。</li></ul><h4 id="2-3-内存屏障插入策略"><a href="#2-3-内存屏障插入策略" class="headerlink" title="2.3 内存屏障插入策略"></a>2.3 内存屏障插入策略</h4><p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><p>上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。</p><h5 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h5><p>下面是保守策略下，<strong>volatile写插入内存屏障</strong>后生成的指令序列示意图。</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232956725.png" alt="image-20230328232956725"></p><p><strong>分析</strong></p><ul><li>上图中StoreStore屏障*<u><strong>可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。</strong></u>*（这就是实现了volatile变量的可见性）</li><li>而volatile写后面的StoreLoad屏障，作用是避免volatile写与后面可能有的volatile读&#x2F;写操作重排序。</li></ul><h5 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h5><p>下图是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328233008162.png" alt="image-20230328233008162"></p><p><strong>分析</strong></p><ul><li>上图中LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。</li><li>LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。</li></ul><p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变 volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。</p><h3 id="三、volatile为什么不保证原子性"><a href="#三、volatile为什么不保证原子性" class="headerlink" title="三、volatile为什么不保证原子性"></a>三、volatile为什么不保证原子性</h3><p>volatile变量的复合操作（如i++）是不具有原子性的，原因是 i++ 操作从字节码角度来看，分为三步：</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328233844628.png" alt="image-20230328233844628"></p><p> 多线程环境下，数据计算和数据赋值操作可能多次出现，即操作非原子。若数据再加载之后，若主内存中 count变量发生修改之后，由于线程工作内存中的值在此之前已经加载，从而不会对变更操作做出相应变化，即私有内存和公共内存中变量不同步，进而导致数据不一致。</p><p>对于volatile变量，JVM只是保证从主内存加载到线程工作内存的值是最新的，也就是数据加载时是最新的。</p><blockquote><p>提问：那为啥synchronized可以保证原子性？</p></blockquote><p>synchronized的执行内部代码的过程分为五步，分别是：</p><ul><li>1、获得同步锁；</li><li>2、清空工作内存；</li><li>3、在主内存中拷贝最新变量的副本到工作内存；</li><li>4、执行代码（计算或者输出等）；</li><li>5、将更改后的共享变量的值刷新到主内存中；</li><li>6、 释放同步锁。</li></ul><p>在主内存中拷贝最新变量的副本到工作内存后，只有同步块中的线程能修改i的值，所以可以保证原子性。</p><h3 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h3><ul><li>使用内存屏障分析下面代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        i = <span class="hljs-number">1</span>;<br>        flag = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>写操作</strong>：</p><ul><li>在每一个volatile写操作 <strong>前面</strong> 插入一个 <strong>storestore屏障</strong></li><li>在每一个volatile写操作 <strong>后面</strong> 插入一个 <strong>storeload屏障</strong></li></ul><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>i &#x3D; 1</td><td>普通写</td></tr><tr><td>storestore屏障</td><td>禁止上面的普通写与下面的volatile写重排序</td></tr><tr><td>flag &#x3D; true</td><td>volatile写</td></tr><tr><td>storeload屏障</td><td>禁止上面的volatile写与下面可能有的volatile读&#x2F;写重排序</td></tr></tbody></table><p><strong>读操作</strong>：</p><ul><li>在每一个volatile读操作 <strong>后面</strong> 插入一个 <strong>loadload屏障</strong></li><li>在每一个volatile读操作 <strong>后面</strong> 插入一个 <strong>loadstore屏障</strong></li></ul><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>if (flag)</td><td>volatile读</td></tr><tr><td>loadload屏障</td><td>禁止上面的volatile读与下面的普通读重排序</td></tr><tr><td>loadstore屏障</td><td>禁止上面的volatile读与下面的普通写重排序</td></tr><tr><td>System.out.println</td><td>普通读</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMM之有序性介绍</title>
    <link href="/2023/03/28/JMM%E4%B9%8B%E6%9C%89%E5%BA%8F%E6%80%A7%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/03/28/JMM%E4%B9%8B%E6%9C%89%E5%BA%8F%E6%80%A7%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>对于一个线程的执行代码而言，我们总是习惯性认为代码的执行总是从上到下，有序执行。</p><p>但为了提升性能，编译器和处理器通常会对指令序列进行<strong>重新排序</strong>。</p><p>Java规范规定JVM线程内部维持<strong>顺序化语义</strong>，即只要程序的最终结果与它顺序化执行的结果一致，那么指令的执行顺序可以与代码顺序<strong>不一致，此过程叫指令的重排序</strong>。</p><p><strong>指令重排序类型</strong></p><p>（1）<strong>编译器优化的重排序</strong>：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</p><p>（2）<strong>指令级并行的重排序</strong>：现代处理器采用了指令级并行技术（ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</p><p>（3）<strong>内存系统的重排序</strong>：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328231244419.png" alt="image-20230328231244419"></p><p>上述的1属于编译器重排序，2和3属于处理器重排序。这些<strong>重排序可能会导致多线程程序出现内存可见性问题</strong>。</p><p><strong>指令重排序优缺点</strong></p><ul><li><strong>优点</strong>：JVM能根据处理器特性（CPU多级缓存系统、多核处理等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度发挥机器性能。</li><li><strong>缺点</strong>：指令重排序<strong>可以保证串行语义一致</strong>，但没有义务保证<strong>多线程之间的语义一致</strong>（即可能产生“脏读”）。</li></ul><h3 id="二、代码解读指令重排"><a href="#二、代码解读指令重排" class="headerlink" title="二、代码解读指令重排"></a>二、代码解读指令重排</h3><p><code>JVM</code>会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> i;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> j;<br><span class="hljs-comment">// 在某个线程内执行如下赋值操作</span><br>i = ...;<br>j = ...;<br></code></pre></td></tr></table></figure><p>可以看到，至于是先执行 i 还是 先执行 j ，对最终的结果不会产生影响。所以，上面代码真正执行时，既可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">i = ...;<br>j = ...;<br></code></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">j = ...;<br>i = ...;<br></code></pre></td></tr></table></figure><p>这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。为什么要有重排指令这项优化呢？从 CPU 执行指令的原理来理解一下吧</p><h3 id="三、指令级并行原理"><a href="#三、指令级并行原理" class="headerlink" title="三、指令级并行原理"></a>三、指令级并行原理</h3><p><strong>指令重排序优化</strong></p><p>事实上，现代处理器会设计为一个时钟周期完成一条执行时间最长的 CPU 指令。为什么这么做呢？可以想到指令还可以再划分成一个个更小的阶段，例如，每条指令都可以分为： <code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code>这 5 个阶段。</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232128544.png" alt="image-20230328232128544"></p><blockquote><p>术语参考：</p><p>instruction fetch (IF)</p><p>instruction decode (ID)</p><p>execute (EX)</p><p>memory access (MEM)</p><p>register write back (WB)</p></blockquote><p>在不改变程序结果的前提下，这些指令的各个阶段可以通过重排序和组合来实现指令级并行，分阶段、分工正是提升效率的关键！</p><p><strong>支持流水线的处理器</strong></p><p>现代 CPU 支持<strong>多级指令流水线</strong>，例如支持同时执行<code>取指令 - 指令译码 - 执行指令 - 内存访问 - 数据写回</code>的处理器，就可以称之为<strong>五级指令流水线</strong>。这时 CPU 可以在一个时钟周期内，同时运行五条指令的不同阶段（相当于一 条执行时间最长的复杂指令），IPC &#x3D; 1，本质上，流水线技术并不能缩短单条指令的执行时间，但它变相地提高了 指令地吞吐率。</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232144396.png" alt="image-20230328232144396"></p><p>大多数处理器包含多个执行单元，并不是所有计算功能都集中在一起，可以再细分为整数运算单元、浮点数运算单元等，这样可以把多条指令也可以做到并行获取、译码等，CPU 可以在一个时钟周期内，执行多于一条指令，IPC&gt;1。</p><h3 id="四、指令重排序带来的问题"><a href="#四、指令重排序带来的问题" class="headerlink" title="四、指令重排序带来的问题"></a>四、指令重排序带来的问题</h3><h4 id="4-1-诡异的结果"><a href="#4-1-诡异的结果" class="headerlink" title="4.1 诡异的结果"></a>4.1 诡异的结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 线程1 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>        r.r1 = num + num;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        r.r1 = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 线程2 执行此方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>    num = <span class="hljs-number">2</span>;<br>    ready = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>I_Result 是一个对象，有一个属性 r1 用来保存结果，问，可能的结果有几种？</p><ul><li>情况1：线程1 先执行，这时 ready &#x3D; false，所以进入 else 分支结果为 1</li><li>情况2：线程2 先执行 num &#x3D; 2，但没来得及执行 ready &#x3D; true，线程1 执行，还是进入 else 分支，结果为1</li><li>情况3：线程2 执行到 ready &#x3D; true，线程1 执行，这回进入 if 分支，结果为 4（因为 num 已经执行过了）</li><li>情况4：线程2 执行 ready &#x3D; true，切换到线程1，进入 if 分支，相加结果为 0，再切回线程2 执行 num &#x3D; 2（*<u>情况4由于指令重排序出现里问题）</u>*</li></ul><p>这种现象叫做指令重排，是 JIT 编译器在运行时的一些优化</p><ul><li>这个现象需要通过大量测试才能复现：借助 java 并发压测工具jcstress（Java Concurrency Stress）</li><li>jmeter侧重对于接口整体的响应速度等进行测试，而JCStress框架能对某块逻辑代码进行高并发测试，更加侧重JVM，类库等领域的研究</li></ul><h4 id="4-2-指令重排的说明"><a href="#4-2-指令重排的说明" class="headerlink" title="4.2 指令重排的说明"></a>4.2 指令重排的说明</h4><ul><li>指令重排序操作不会对存在数据依赖关系的操作进行重排序。比如：a&#x3D;1;b&#x3D;a; 这个指令序列，*<u><strong>由于第二个操作依赖于第一个操作，所以在编译时和处理器运行时这两个操作不会被重排序。</strong></u>*</li><li>*<u><strong>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</strong></u>*。 比如：a&#x3D;1;b&#x3D;2;c&#x3D;a+b这三个操作，第一步（a&#x3D;1)和第二步(b&#x3D;2)由于不存在数据依赖关系，所以可能会发生重排序，但是c&#x3D;a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c&#x3D;a+b&#x3D;3。</li></ul><p><em><u><strong>指令重排序在单线程模式下是一定会保证最终结果的正确性， 但是在多线程环境下，问题就出来了。</strong></u></em></p><h3 id="五、解决方法"><a href="#五、解决方法" class="headerlink" title="五、解决方法"></a>五、解决方法</h3><p>volatile 修饰的变量，可以禁用指令重排</p><blockquote><p>注：对于volatile禁止指令重排的原理见文章：<a href="https://weiyikai.site/2023/03/28/volatile%E5%8E%9F%E7%90%86">volatile原理</a></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openjdk.jcstress.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jcstress.infra.results.I_Result;<br><br><span class="hljs-meta">@JCStressTest</span> <span class="hljs-comment">// 标记此类为一个并发测试类</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span> <span class="hljs-comment">// 标记此类是有状态的</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrencyTest</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//加上 volatile 防止 修改ready操作 之前的写指令重排</span><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>        <span class="hljs-keyword">if</span>(ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">*** INTERESTING tests<br>  <span class="hljs-literal">Some</span> interesting behaviors observed. This is <span class="hljs-keyword">for</span> <span class="hljs-title class_">the</span> plain curiosity.<br><br>  <span class="hljs-number">0</span> matching test results.<br></code></pre></td></tr></table></figure><p><em>思考：是否可以通过synchronized来解决该问题？</em></p><blockquote><p>使用<code>synchronized并不能解决有序性</code>问题，<strong>但是如果是该<code>变量</code>整个都在synchronized代码块的保护范围内</strong>，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！在这种情况下相当于解决了重排序问题！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两阶段终止模式和Balking模式</title>
    <link href="/2023/03/28/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E5%92%8CBalking%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/03/28/%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%E5%92%8CBalking%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我已经在语雀上介绍了相关两阶段终止模式，具体文章见：<a href="https://www.yuque.com/weiyikai/java/fn9aim93c09h3qqe"><strong>终止模式之两阶段终止模式</strong></a></p></blockquote><h3 id="一、volatile改进两阶段终止模式"><a href="#一、volatile改进两阶段终止模式" class="headerlink" title="一、volatile改进两阶段终止模式"></a>一、volatile改进两阶段终止模式</h3><h4 id="1-1-示例"><a href="#1-1-示例" class="headerlink" title="1.1 示例"></a>1.1 示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/29</span><br><span class="hljs-comment"> * Description volatile实现两阶段终止</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test09&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test09</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();<br>        tpt.start();<br><br>        Thread.sleep(<span class="hljs-number">3500</span>);<br>        log.debug(<span class="hljs-string">&quot;停止监控&quot;</span>);<br>        tpt.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-comment">// 监控线程</span><br>    <span class="hljs-keyword">private</span> Thread monitorThread;<br>    <span class="hljs-comment">// 停止标记</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 启动监控线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        monitorThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">//是否被打断</span><br>                <span class="hljs-keyword">if</span>(stop)&#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        monitorThread.start();<br>    &#125;<br><br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        monitorThread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">09:55:59.124 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">09:56:00.131 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">09:56:01.132 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">09:56:01.623 c.Test09 [main] - 停止监控</span><br><span class="hljs-section">java.lang.InterruptedException: sleep interrupted</span><br>    at java.lang.Thread.sleep(Native Method)<br>    at com.lilinchao.concurrent.demo_03.TwoPhaseTermination.lambda$start$0(Test09.java:40)<br>    at java.lang.Thread.run(Thread.java:748)<br><span class="hljs-section">09:56:01.624 c.TwoPhaseTermination [t1] - 料理后事</span><br></code></pre></td></tr></table></figure><p><strong>代码分析</strong></p><ul><li><code>TwoPhaseTermination</code>类中调用start()方法，启动一个<code>t1</code>线程。</li><li>t1线程中while(true)方法循环执行监控记录，使得t1线程无法结束。</li><li>stop方法初始值为false,t1线程刚启动时，不会进入<code>if(stop)</code>条件判断中执行<code>break;</code>退出循环。</li><li>stop()方法中将成员变量stop改为true,同时调用<code>monitorThread.interrupt();</code>方法，为了打断正在睡眠中的t1线程，使其停止睡眠立即向下执行。</li><li>要想使t1线程能够读取到成员变量stop在主线程中的更改，加上关键字<code>volatile</code></li></ul><p><strong>执行过程分析</strong></p><ul><li>主线程中调用<code>TwoPhaseTermination</code>类的start()方法，开启t1线程；</li><li>t1线程中每睡眠1s控制台输出一次“执行监控记录”；</li><li>主线程在3.5秒后调用stop()方法，将stop设置成true，准备停止t1线程；</li><li>此时t1线程已经执行完第三轮循环，正处于第四轮循环的睡眠状态，但是被<code>monitorThread.interrupt();</code>方法打断睡眠，抛出一个打断异常后，开始第五轮循环；</li><li>此时stop成员变量为true,进入if判断条件，料理后事后退出循环；</li><li>t1线程运行结束，退出。</li></ul><h4 id="1-2-该方式存在的缺陷"><a href="#1-2-该方式存在的缺陷" class="headerlink" title="1.2 该方式存在的缺陷"></a>1.2 该方式存在的缺陷</h4><p>当我们多次调用start()方法时，会创建多个t1线程，整个线程都在重复执行，消耗资源且没有意义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();<br>    tpt.start();<br>    tpt.start();<br><br>    Thread.sleep(<span class="hljs-number">3500</span>);<br>    log.debug(<span class="hljs-string">&quot;停止监控&quot;</span>);<br>    tpt.stop();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">10:04:33.048 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:04:33.049 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:04:34.052 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:04:34.052 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:04:35.052 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:04:35.052 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:04:35.547 c.Test09 [main] - 停止监控</span><br><span class="hljs-section">java.lang.InterruptedException: sleep interrupted</span><br>    at java.lang.Thread.sleep(Native Method)<br>    at com.lilinchao.concurrent.demo_03.TwoPhaseTermination.lambda$start$0(Test09.java:41)<br>    at java.lang.Thread.run(Thread.java:748)<br><span class="hljs-section">10:04:35.549 c.TwoPhaseTermination [t1] - 料理后事</span><br><span class="hljs-section">10:04:36.053 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:04:36.053 c.TwoPhaseTermination [t1] - 料理后事</span><br></code></pre></td></tr></table></figure><p><strong>问题？</strong></p><p>如何保证某个方法被多次调用时，只会执行一次，下次在执行直接返回，不再继续向下执行。</p><p>可以通过Balking模式来实现。</p><h3 id="二、Balking模式"><a href="#二、Balking模式" class="headerlink" title="二、Balking模式"></a>二、Balking模式</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p><em><u>Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做了，直接结束返回。</u></em></p><h4 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h4><p>Balking模式就是加入一个全局变量starting，通过starting的状态来判断该线程是否被调用过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting;<br></code></pre></td></tr></table></figure><p>在调用方法中加入条件判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (starting) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>starting = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><ul><li>当方法第一次被调用，starting变量为false,不进入条件判断语句，继续向下执行，这时将starting状态改为true;</li><li>当方法已经被调用过时，此时状态值starting被改为true,进入到条件判断当中，执行return，退出该方法。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitorService</span> &#123;<br>    <span class="hljs-comment">// 用来表示是否已经有线程已经在执行启动了</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> starting;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;尝试启动监控线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 真正启动监控线程...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><em>思考：为什么需要在Balking模式代码中加上synchronized锁？</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (starting) &#123;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br>starting = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p>因为上方几段代码即涉及到了读，也涉及到了写，对于多行语句，在多线程情况下，保证的就不仅仅是可见性，必须得保证代码的原子性。所以，上方几段代码必须放在synchronized代码块中。</p><h3 id="三、Balking模式应用"><a href="#三、Balking模式应用" class="headerlink" title="三、Balking模式应用"></a>三、Balking模式应用</h3><p>对上方volatile实现两阶段终止模式代码通过Balking模式进行改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/29</span><br><span class="hljs-comment"> * Description Balking模式应用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test09&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test09</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">TwoPhaseTermination</span> <span class="hljs-variable">tpt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TwoPhaseTermination</span>();<br>        tpt.start();<br>        tpt.start();<br>        tpt.start();<br><br>        <span class="hljs-comment">/*Thread.sleep(3500);</span><br><span class="hljs-comment">        log.debug(&quot;停止监控&quot;);</span><br><span class="hljs-comment">        tpt.stop();*/</span><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TwoPhaseTermination&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoPhaseTermination</span> &#123;<br>    <span class="hljs-comment">// 监控线程</span><br>    <span class="hljs-keyword">private</span> Thread monitorThread;<br>    <span class="hljs-comment">// 停止标记</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 判断是否执行过 start 方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">starting</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// 启动监控线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">if</span> (starting) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            starting = <span class="hljs-literal">true</span>;<br>        &#125;<br>        monitorThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-comment">//是否被打断</span><br>                <span class="hljs-keyword">if</span>(stop)&#123;<br>                    log.debug(<span class="hljs-string">&quot;料理后事&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    log.debug(<span class="hljs-string">&quot;执行监控记录&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        monitorThread.start();<br>    &#125;<br><br><br>    <span class="hljs-comment">//停止监控线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span>&#123;<br>        stop = <span class="hljs-literal">true</span>;<br>        monitorThread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">10:44:22.543 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:23.546 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:24.547 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:25.547 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:26.561 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:27.561 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:28.562 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:29.562 c.TwoPhaseTermination [t1] - 执行监控记录</span><br><span class="hljs-section">10:44:30.563 c.TwoPhaseTermination [t1] - 执行监控记录</span><br></code></pre></td></tr></table></figure><p>从结果可以看出，每隔1s输出一次记录，不会再像之前一样，每秒打印多次记录。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMM之可见性介绍</title>
    <link href="/2023/03/28/JMM%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/03/28/JMM%E4%B9%8B%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Java内存模型"><a href="#一、Java内存模型" class="headerlink" title="一、Java内存模型"></a>一、Java内存模型</h3><p>JMM即Java Memory Model,它定义了<strong>主存、工作内存抽象概念，</strong>底层对应着CPU寄存器、缓存、硬件内存、CPU指令优化等。</p><p><strong>JMM 体现在以下几个方面</strong></p><ul><li><strong>原子性</strong>：保证指令不会受到线程上下文切换的影响</li><li><strong>可见性</strong>：保证指令不会受 cpu 缓存的影响</li><li><strong>有序性</strong>：保证指令不会受 cpu 指令并行优化的影响</li></ul><p>简单的说，<strong>JMM</strong> 定义了一套<strong>在多线程读写共享数据时</strong>（成员变量、数组）时，对数据的可见性、有序性和原子性的规则和保障。</p><h3 id="二、不可见性导致的问题"><a href="#二、不可见性导致的问题" class="headerlink" title="二、不可见性导致的问题"></a>二、不可见性导致的问题</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/27</span><br><span class="hljs-comment"> * Description 退不出的循环</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test06&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run)&#123;<br><br>            &#125;<br>        &#125;);<br>        t.start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;停止t线程...&quot;</span>);<br>        run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232241773.png" alt="image-20230328232241773"></p><p>从结果可以看出，当run变量为false后，t线程并未退出循环。</p><p><strong>问题分析</strong></p><p>1、初始状态，t线程刚开始从主内存读取了run 的值到工作内存。</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232254219.png" alt="image-20230328232254219"></p><p>2、因为t线程要频繁从主内存中读取run的值，JIT编译器会将run的值缓存至自己工作内存中的高速缓存 中，减少对主存中run的访问，提高效率</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232306676.png" alt="image-20230328232306676"></p><p>3、1秒之后， main线程修改了run的值，并同步至主存，而t是从自己工作内存中的高速缓存中读取这个变 量的值，结果永远是旧值</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328232322029.png" alt="image-20230328232322029"></p><h3 id="三、可见性"><a href="#三、可见性" class="headerlink" title="三、可见性"></a>三、可见性</h3><h4 id="3-1-volatile（易变关键字）"><a href="#3-1-volatile（易变关键字）" class="headerlink" title="3.1 volatile（易变关键字）"></a>3.1 volatile（易变关键字）</h4><p>它可以用来修饰成员变量和静态成员变量，它可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/27</span><br><span class="hljs-comment"> * Description 退不出的循环 -- volatile解决办法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test06&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run)&#123;<br><br>            &#125;<br>        &#125;);<br>        t.start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;停止t线程...&quot;</span>);<br>        run = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">21:49:15.174 c.Test06 [main] - 停止t线程...</span><br></code></pre></td></tr></table></figure><p>线程t在1s后正常退出了循环。</p><p><strong>分析</strong></p><p>当主线程修改主存中的run变量的时候,t线程一直访问的是自己缓存的run值，所以不认为run已经改为false，顾不会退出循环。</p><p>当为主存(成员变量)进行volatile修饰，增加变量的可见性, 当主线程修改run为false, t线程对run的值可见，这样就可以正常退出循环。</p><h4 id="3-2-synchronized的可见性"><a href="#3-2-synchronized的可见性" class="headerlink" title="3.2 synchronized的可见性"></a>3.2 synchronized的可见性</h4><p>synchronized的执行内部代码的过程分为五步，分别是：</p><ul><li>1、获得同步锁；</li><li>2、清空工作内存；</li><li>3、在主内存中拷贝最新变量的副本到工作内存；</li><li>4、执行代码（计算或者输出等）；</li><li>5、将更改后的共享变量的值刷新到主内存中；</li><li>6、 释放同步锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/27</span><br><span class="hljs-comment"> * Description 退不出的循环 -- synchronized解决办法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test07&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test07</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">run</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run) &#123;<br>                <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                    <span class="hljs-keyword">if</span> (!run)&#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        t.start();<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;停止t线程...&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            run = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">22:09:18.867 c.Test07 [main] - 停止t线程...</span><br></code></pre></td></tr></table></figure><h4 id="3-3-print打印输出"><a href="#3-3-print打印输出" class="headerlink" title="3.3 print打印输出"></a>3.3 print打印输出</h4><p>当在while循环代码中加入print打印输出时，t线程会退出循环。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> lombok.<span class="hljs-property">extern</span>.<span class="hljs-property">slf4j</span>.<span class="hljs-property">Slf4j</span>;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.<span class="hljs-property">weiyikai</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">utils</span>.<span class="hljs-property">Sleeper</span>.<span class="hljs-property">sleep</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/27</span><br><span class="hljs-comment"> * Description 退不出的循环 -- print打印输出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span>(topic = <span class="hljs-string">&quot;c.Test06&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> run = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Thread</span> t = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (run)&#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125;);<br>        t.<span class="hljs-title function_">start</span>();<br><br>        <span class="hljs-title function_">sleep</span>(<span class="hljs-number">1</span>);<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;停止t线程...&quot;</span>);<br>        run = <span class="hljs-literal">false</span>; <span class="hljs-comment">// 线程t不会如预想的停下来</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">22:10:28.651 c.Test06 [main] - 停止t线程...</span><br></code></pre></td></tr></table></figure><p><strong>分析</strong></p><p>从print的源码中可以看出，print方法使用到了<code>synchronized</code>，synchronized可以保证原子性、可见性、有序性。当使用synchronized后，就会将线程的工作内存清空，在主内存中拷贝最新变量的副本到工作内存。所以会获取到正确的run值。</p><h3 id="四、可见性-vs-原子性"><a href="#四、可见性-vs-原子性" class="headerlink" title="四、可见性 vs 原子性"></a>四、可见性 vs 原子性</h3><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线 程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况。</p><p>上例从字节码理解是这样的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">getstatic run // 线程 t 获取 run <span class="hljs-literal">true</span><br>getstatic run // 线程 t 获取 run <span class="hljs-literal">true</span><br>getstatic run // 线程 t 获取 run <span class="hljs-literal">true</span><br>getstatic run // 线程 t 获取 run <span class="hljs-literal">true</span><br>putstatic run // 线程 main 修改 run 为 <span class="hljs-literal">false</span>， 仅此一次<br>getstatic run // 线程 t 获取 run <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>比较一下之前讲线程安全时举的例子：两个线程一个 <code>i++</code> 一个 <code>i- -</code>，只能保证看到最新值，不能解决指令交错。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 假设i的初始值为0</span><br><span class="hljs-selector-tag">getstatic</span>     <span class="hljs-selector-tag">i</span>     <span class="hljs-comment">// 线程2-获取静态变量i的值 线程内i=0</span><br><br><span class="hljs-selector-tag">getstatic</span>     <span class="hljs-selector-tag">i</span>     <span class="hljs-comment">// 线程1-获取静态变量i的值 线程内i=0</span><br><span class="hljs-selector-tag">iconst_1</span>         <span class="hljs-comment">// 线程1-准备常量1</span><br><span class="hljs-selector-tag">iadd</span>             <span class="hljs-comment">// 线程1-自增 线程内i=1</span><br><span class="hljs-selector-tag">putstatic</span>     <span class="hljs-selector-tag">i</span>     <span class="hljs-comment">// 线程1-将修改后的值存入静态变量i 静态变量i=1</span><br><br><span class="hljs-selector-tag">iconst_1</span>         <span class="hljs-comment">// 线程2-准备常量1</span><br><span class="hljs-selector-tag">isub</span>             <span class="hljs-comment">// 线程2-自减 线程内i=-1</span><br><span class="hljs-selector-tag">putstatic</span>     <span class="hljs-selector-tag">i</span>     <span class="hljs-comment">// 线程2-将修改后的值存入静态变量i 静态变量i=-1</span><br></code></pre></td></tr></table></figure><p>synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>volatile关键字可以保证可见性、有序性，但是不能保证原子性。volatile具体原理见：<a href="https://weiyikai.site/2023/03/28/volatile%E5%8E%9F%E7%90%86">volatile原理</a></p><p> synchronized关键字可以保证可见性、原子性，对于有序性：使用<code>synchronized并不能解决有序性</code>问题，<strong>但是如果是该<code>变量</code>整个都在synchronized代码块的保护范围内</strong>，那么变量就不会被多个线程同时操作，也不用考虑有序性问题！在这种情况下相当于解决了重排序问题！。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>同步模式之顺序控制（笔试）</title>
    <link href="/2023/03/28/%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E7%AC%94%E8%AF%95%EF%BC%89/"/>
    <url>/2023/03/28/%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E7%AC%94%E8%AF%95%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="一、固定运行顺序"><a href="#一、固定运行顺序" class="headerlink" title="一、固定运行顺序"></a>一、固定运行顺序</h3><blockquote><p>题目：有两个线程分别输出1和2，要求输出结果必须先2后1打印</p></blockquote><h4 id="1-1-wait-notify-版"><a href="#1-1-wait-notify-版" class="headerlink" title="1.1 wait notify 版"></a>1.1 wait notify 版</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 固定运行顺序  wait notify实现</span><br><span class="hljs-comment"> * 必须先2后1打印</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> &#123;<br>    <span class="hljs-comment">// 用来同步的对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">//表示 t2 是否运行过</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">t2runned</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>                <span class="hljs-comment">// 如果 t2 没有执行过</span><br>                <span class="hljs-keyword">while</span> (!t2runned)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// t1 先等一会</span><br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                <span class="hljs-comment">// 修改运行标记</span><br>                t2runned = <span class="hljs-literal">true</span>;<br>                <span class="hljs-comment">// 通知 obj 上等待的线程（可能有多个，因此需要用 notifyAll）</span><br>                lock.notifyAll();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">20:54:47.396 c.Test01 [t2] - 2</span><br><span class="hljs-section">20:54:47.398 c.Test01 [t1] - 1</span><br></code></pre></td></tr></table></figure><p>可以看到，实现上很麻烦：</p><ul><li>首先，需要保证先 wait 再 notify，否则 wait 线程永远得不到唤醒。因此使用了『运行标记』来判断该不该 wait；</li><li>第二，如果有些干扰线程错误地 notify 了 wait 线程，条件不满足时还要重新等待，使用了 while 循环来解决 此问题；</li><li>最后，唤醒对象上的 wait 线程需要使用 <code>notifyAll</code>，因为『同步对象』上的等待线程可能不止一个。</li></ul><h4 id="1-2-await-x2F-signal版本实现"><a href="#1-2-await-x2F-signal版本实现" class="headerlink" title="1.2 await&#x2F;signal版本实现"></a>1.2 await&#x2F;signal版本实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 固定运行顺序 - await/signal版本实现</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test06&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-comment">// t2线程释放执行过</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">t2Runned</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 临界区</span><br>                <span class="hljs-keyword">while</span> (!t2Runned) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        condition.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2Runned = <span class="hljs-literal">true</span>;<br>                condition.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">21:38:38.463 c.Test06 [t2] - 2</span><br><span class="hljs-section">21:38:38.464 c.Test06 [t1] - 1</span><br></code></pre></td></tr></table></figure><h4 id="1-3-Park-Unpark-版"><a href="#1-3-Park-Unpark-版" class="headerlink" title="1.3 Park Unpark 版"></a>1.3 Park Unpark 版</h4><p>可以使用 <code>LockSupport</code> 类的 park 和 <code>unpark</code> 来简化上面的题目：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 固定运行顺序 Park Unpark实现</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test02&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 当没有『许可』时，当前线程暂停运行；有『许可』时，用掉这个『许可』，当前线程恢复运行</span><br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>            <span class="hljs-comment">// 给线程 t1 发放『许可』（多次连续调用 unpark 只会发放一个『许可』）</span><br>            LockSupport.unpark(t1);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">21:33:28.193 c.Test02 [t2] - 2</span><br><span class="hljs-section">21:33:28.195 c.Test02 [t1] - 1</span><br></code></pre></td></tr></table></figure><p>park 和 unpark 方法比较灵活，他俩谁先调用，谁后调用无所谓。并且是以线程为单位进行『暂停』和『恢复』， 不需要『同步对象』和『运行标记』</p><h3 id="二、交替输出"><a href="#二、交替输出" class="headerlink" title="二、交替输出"></a>二、交替输出</h3><blockquote><p>题目：线程1 输出 a 5次, 线程2 输出 b 5次, 线程3 输出 c 5次。现在要求输出 abcabcabcabcabcab</p></blockquote><h4 id="2-1-wait-x2F-notify版本"><a href="#2-1-wait-x2F-notify版本" class="headerlink" title="2.1 wait&#x2F;notify版本"></a>2.1 wait&#x2F;notify版本</h4><p>通过设置等待标记 flag 来记录当前拥有锁的是哪个线程， 设置下一个标记，来记录下一个唤醒的该是哪个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 交替输出 wait notify实现</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify</span> <span class="hljs-variable">waitNotify</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify</span>(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify.print(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify.print(<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            waitNotify.print(<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出内容       等待标记     下一个标记</span><br><span class="hljs-comment">   a           1             2</span><br><span class="hljs-comment">   b           2             3</span><br><span class="hljs-comment">   c           3             1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span> &#123;<br><br>    <span class="hljs-comment">// 打印</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,<span class="hljs-type">int</span> waitFlag,<span class="hljs-type">int</span> nextFlag)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++)&#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">while</span> (flag != waitFlag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                <span class="hljs-comment">// 修改等待标记 让下一个线程打印</span><br>                flag = nextFlag;<br>                <span class="hljs-comment">// 唤醒等待线程</span><br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 等待标记</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag;<br>    <span class="hljs-comment">// 循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">abcabcabcabcabc<br></code></pre></td></tr></table></figure><h4 id="2-2-await-x2F-signal版本"><a href="#2-2-await-x2F-signal版本" class="headerlink" title="2.2 await&#x2F;signal版本"></a>2.2 await&#x2F;signal版本</h4><p>由于 <code>ReentrantLock</code> 具有多个条件变量的特性，即多个 <code>WaitSet</code> 休息室，所以可以通过设置让其进入不同的休息室休息来实现输出当前线程的字符串，并唤醒下一个休息室中的线程。这种方法存在虚假唤醒的情况，因为没有做 while 判断，但此例中每个休息室中只有一个线程，因此不存在虚假唤醒的情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.thread.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-26 交替输出 await/signal</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">awaitSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>,a,b);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>,b,c);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>,c,a);<br>        &#125;).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        awaitSignal.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始...&quot;</span>);<br>            a.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            awaitSignal.unlock();<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 打印</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str 打印内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> current   进入哪一间休息室</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> next  下一间休息室</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition current,Condition next)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++)&#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                current.await();<br>                System.out.print(str);<br>                next.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">开始...<br>abcabcabcabcabc<br></code></pre></td></tr></table></figure><h4 id="2-3-park-x2F-unpark实现"><a href="#2-3-park-x2F-unpark实现" class="headerlink" title="2.3 park&#x2F;unpark实现"></a>2.3 park&#x2F;unpark实现</h4><p>park和unpark没有对象锁的概念了，停止和恢复线程的运行都是以线程自身为单位的，所以实现更为简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-26</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 交替输出 Park/Unpark</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test05&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test05</span> &#123;<br>    <span class="hljs-keyword">static</span> Thread t1;<br>    <span class="hljs-keyword">static</span> Thread t2;<br>    <span class="hljs-keyword">static</span> Thread t3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ParkUnpark</span> <span class="hljs-variable">unpark</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParkUnpark</span>(<span class="hljs-number">5</span>);<br>        t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            unpark.print(<span class="hljs-string">&quot;a&quot;</span>, t2);<br>        &#125;);<br>        t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            unpark.print(<span class="hljs-string">&quot;b&quot;</span>, t3);<br>        &#125;);<br>        t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            unpark.print(<span class="hljs-string">&quot;c&quot;</span>, t1);<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br>        <span class="hljs-comment">//主线程先唤醒t1</span><br>        LockSupport.unpark(t1);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkUnpark</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str,Thread next)</span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++)&#123;<br>            <span class="hljs-comment">//当前线程先暂停</span><br>            LockSupport.park();<br>            System.out.print(str);<br>            <span class="hljs-comment">//唤醒下一个线程</span><br>            LockSupport.unpark(next);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParkUnpark</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">abcabcabcabcabc<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ReentrantLock</title>
    <link href="/2023/03/28/ReentrantLock/"/>
    <url>/2023/03/28/ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>ReentrantLock是一种基于AQS框架的应用实现，是JDK中的一种线程并发访问的同步手段，它的功能类似于synchronized是一种互斥锁，可以保证线程安全。</p><p><strong>相对于 synchronized 它具备如下特点:</strong></p><ul><li>可中断（等待获取锁的过程中可以被打断）<ul><li>synchronized锁加上去不能中断，a线程应用锁，b线程不能取消掉它</li></ul></li><li>可以设置超时时间<ul><li>synchronized它去获取锁时，如果对方持有锁，那么它就会进入entryList一直等待下去。而ReentrantLock可以设置超时时间，规定时间内如果获取不到锁，就放弃锁。</li></ul></li><li>可以设置为公平锁<ul><li>防止线程饥饿的情况，即先到先得。如果争抢的人比较多，则可能会发生永远都得不到锁。</li></ul></li><li>支持多个条件变量（相当于有多个EntryList）<ul><li>synchronized只支持同一个waitset。</li></ul></li><li><strong>与 synchronized 一样，都支持可重入</strong></li></ul><h3 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h3><p><strong>步骤</strong></p><p>（1）创建一个<code>ReentrantLock</code>对象；</p><p>（2）调用<code>ReentrantLock</code>对象的<code>lock()</code>方法；</p><p>（3）将临界区的代码写在try代码块中；</p><p>（4）将<code>ReentrantLock</code>对象的<code>unlock()</code>方法写在finally代码块中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">// 获取锁</span><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>synchronized是在关键字的级别来保护临界区，而reentrantLock是在对象的级别保护临界区。</strong>临界区即访问共享资源的那段代码。</li><li><code>finally</code>中表明不管将来是否出现异常，都会释放锁，释放锁即调用unlock方法。否则无法释放锁，其它线程就永远也获取不了锁。</li></ul><p>注意：<code>lock.lock();</code>与try代码块之间<strong>不要有空行</strong>或者其它逻辑，且<code>lock.unlock();</code>要写在finally代码块的<strong>第一行</strong>。</p><h3 id="三、可重入"><a href="#三、可重入" class="headerlink" title="三、可重入"></a>三、可重入</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁;</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</li></ul><h4 id="3-2-代码示例"><a href="#3-2-代码示例" class="headerlink" title="3.2 代码示例"></a>3.2 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> ReentrantLock 可重入</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test03&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test03</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        method1();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;execute method1&quot;</span>);<br>            method2();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;execute method2&quot;</span>);<br>            method3();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method3</span><span class="hljs-params">()</span>&#123;<br>        lock.lock();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;execute method3&quot;</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">58</span>:<span class="hljs-number">48.257</span> c.Test03 [main] - execute method1<br><span class="hljs-number">21</span>:<span class="hljs-number">58</span>:<span class="hljs-number">48.259</span> c.Test03 [main] - execute method2<br><span class="hljs-number">21</span>:<span class="hljs-number">58</span>:<span class="hljs-number">48.259</span> c.Test03 [main] - execute method3<br></code></pre></td></tr></table></figure><p>从运行结果可以看出，当前线程在执行时多次获取锁, 并不会被锁挡住, 而是正常运行</p><p><em>注意：加锁与解锁是必须<strong>匹配</strong>的，只有当解锁次数等于加锁次数时，锁才会被正确释放。</em></p><h3 id="四、可打断"><a href="#四、可打断" class="headerlink" title="四、可打断"></a>四、可打断</h3><h4 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h4><p>可打断是指, 当前线程在等待锁的时候, 可以被其他的线程使用 <code>interrupt()</code> 方法打断。synchronized是不可中断锁，而ReentrantLock则提供了中断功能。</p><p><strong>方法说明</strong></p><ul><li>**lock.lockInterruptibly()**：尝试获取锁，如果获取不到锁，进入等待；等待过程中可以被打断。</li><li><strong>lock.lock()：</strong>等待锁的过程是不可以被打断的。</li></ul><h4 id="4-2-代码示例"><a href="#4-2-代码示例" class="headerlink" title="4.2 代码示例"></a>4.2 代码示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.thread.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 打断ReentrantLock锁</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test04&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lockInterruptibly();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                log.debug(<span class="hljs-string">&quot;等锁的过程中被打断&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">1</span>);<br>            t1.interrupt();<br>            log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">21</span>:<span class="hljs-number">02.967</span> c.Test04 [main] - 获得了锁<br><span class="hljs-number">22</span>:<span class="hljs-number">21</span>:<span class="hljs-number">02.969</span> c.Test04 [t1] - start...<br><span class="hljs-number">22</span>:<span class="hljs-number">21</span>:<span class="hljs-number">03.984</span> c.Test04 [main] - 执行打断<br>java.lang.InterruptedException<br>    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">898</span>)<br>    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchronizer.java:<span class="hljs-number">1222</span>)<br>    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:<span class="hljs-number">335</span>)<br>    at com.lilinchao.thread.demo06.Test04.lambda$main$<span class="hljs-number">0</span>(Test04.java:<span class="hljs-number">22</span>)<br>    at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-number">22</span>:<span class="hljs-number">21</span>:<span class="hljs-number">03.985</span> c.Test04 [t1] - 等锁的过程中被打断<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><p>main线程首先获得锁，因此被创建出的线程t1启动后无法获得锁，之后，main线程打断线程t1，使得线程t1结束等待。</p><h4 id="4-3-不可中断模式"><a href="#4-3-不可中断模式" class="headerlink" title="4.3 不可中断模式"></a>4.3 不可中断模式</h4><p>注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.thread.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 不可中断模式</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test05&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test05</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br><br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">1</span>);<br>            t1.interrupt();<br>            log.debug(<span class="hljs-string">&quot;执行打断&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;释放了锁&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">52.756</span> c.Test05 [main] - 获得了锁<br><span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">52.758</span> c.Test05 [t1] - start...<br><span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">53.771</span> c.Test05 [main] - 执行打断<br><span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">54.777</span> c.Test05 [main] - 释放了锁<br><span class="hljs-number">22</span>:<span class="hljs-number">24</span>:<span class="hljs-number">54.777</span> c.Test05 [t1] - 获得了锁<br></code></pre></td></tr></table></figure><h3 id="五、锁超时"><a href="#五、锁超时" class="headerlink" title="五、锁超时"></a>五、锁超时</h3><h4 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h4><p>可打断，是一种被动的打断，需要其他的线程来进行打断。</p><p>而锁超时可以通过主动方式，来解决线程无限制的等待下去。如果当前线程在等待了一段时间之后，还没有获取锁，将不在继续等待，继续向下执行。</p><p>通过设置获得锁的等待时间，当不能在等待时间内获得锁的时候释放锁，就能够避免死锁的问题。</p><h4 id="5-2-设置超时时间API"><a href="#5-2-设置超时时间API" class="headerlink" title="5.2 设置超时时间API"></a>5.2 设置超时时间API</h4><p>ReetrantLock提供了两个获取锁并快速返回的方法，不会一直等待，无论成功失败都将立即返回。</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1680004120400.png"></p><h4 id="5-3-代码示例"><a href="#5-3-代码示例" class="headerlink" title="5.3 代码示例"></a>5.3 代码示例</h4><ul><li><strong>无参tryLock()方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.thread.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xioawei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 锁超时 - 立刻失败</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test06&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test06</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>            <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>                log.debug(<span class="hljs-string">&quot;获取立即失败，返回&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">40</span>:<span class="hljs-number">21.990</span> c.Test06 [main] - 获得了锁<br><span class="hljs-number">22</span>:<span class="hljs-number">40</span>:<span class="hljs-number">21.992</span> c.Test06 [t1] - start...<br><span class="hljs-number">22</span>:<span class="hljs-number">40</span>:<span class="hljs-number">21.992</span> c.Test06 [t1] - 获取立即失败，返回<br></code></pre></td></tr></table></figure><ul><li><strong>带参tryLock方法</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.thread.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 超时失败</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test07&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test07</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;获取等待 1s 后失败,返回&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>            &#125;<span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得了锁&quot;</span>);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//主线程等待2s</span><br>            sleep(<span class="hljs-number">2</span>);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">41.537</span> c.Test07 [main] - 获得了锁<br><span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">41.539</span> c.Test07 [t1] - start...<br><span class="hljs-number">22</span>:<span class="hljs-number">42</span>:<span class="hljs-number">42.544</span> c.Test07 [t1] - 获取等待 1s 后失败,返回<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><p>代码执行时，main线程先获得了锁，进入到2s的睡眠当中，此时t1线程启动，执行到<code>lock.tryLock(1, TimeUnit.SECONDS)</code>，等待获取到lock锁后继续向下执行。1s后t1线程未获得所，将放弃继续获取锁，t1线程退出。</p><h4 id="5-4-锁超时解决哲学家就餐问题"><a href="#5-4-锁超时解决哲学家就餐问题" class="headerlink" title="5.4 锁超时解决哲学家就餐问题"></a>5.4 锁超时解决哲学家就餐问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> site.weiyikai.thread.utils.Sleeper;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-25</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span></span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test08</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick2</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick2</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">Chopstick2</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick2</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-type">Chopstick2</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick2</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-type">Chopstick2</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick2</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>        <span class="hljs-type">Chopstick2</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick2</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher2</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher2</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher2</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher2</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher2</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Philosopher2&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick2 left;<br>    Chopstick2 right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher2</span><span class="hljs-params">(String name, Chopstick2 left, Chopstick2 right)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 尝试获得左手筷子</span><br>            <span class="hljs-keyword">if</span> (left.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 尝试获得右手筷子</span><br>                    <span class="hljs-keyword">if</span> (right.tryLock()) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            eat();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            right.unlock();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 如果没有获得右手的筷子,则释放自己手里的筷子,破坏了死锁的请求和保持条件</span><br>                    left.unlock();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick2</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">17.080</span> c.Philosopher2 [亚里士多德] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">17.080</span> c.Philosopher2 [苏格拉底] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">18.093</span> c.Philosopher2 [柏拉图] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">18.093</span> c.Philosopher2 [赫拉克利特] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">19.093</span> c.Philosopher2 [苏格拉底] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">19.093</span> c.Philosopher2 [亚里士多德] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">20.101</span> c.Philosopher2 [亚里士多德] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">56</span>:<span class="hljs-number">20.101</span> c.Philosopher2 [阿基米德] - eating...<br>...........<br>程序会一直向下执行，不会产生死锁<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><p>可以看到,需要使用 <code>tryLock</code> 方法去获取左筷子和右筷子, 如果获取失败直接结束, 另外在成功获取锁后，要在 finally 里释放锁。</p><h3 id="六、公平锁"><a href="#六、公平锁" class="headerlink" title="六、公平锁"></a>六、公平锁</h3><h4 id="6-1-概念"><a href="#6-1-概念" class="headerlink" title="6.1 概念"></a>6.1 概念</h4><ul><li><strong>公平锁</strong>：是指多个线程按照申请锁的顺序来获取锁，通过队列FIFO，先进先出，类似排队打饭，先来后到。</li><li><strong>非公平锁</strong>：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。*<u>。</u>*</li></ul><h4 id="6-2-语法"><a href="#6-2-语法" class="headerlink" title="6.2 语法"></a>6.2 语法</h4><p>ReentrantLock默认是<strong>非公平锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// true:公平锁</span><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// todo</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>说明</strong></p><ul><li>初始化构造函数入参，选择是否为初始化公平锁。</li><li>其实一般情况下并不需要公平锁，除非你的场景中需要保证顺序性。</li><li>使用 ReentrantLock 切记需要在 finally 中关闭,lock.unlock()。</li></ul><h5 id="公平锁和非公平锁的选择"><a href="#公平锁和非公平锁的选择" class="headerlink" title="公平锁和非公平锁的选择"></a>公平锁和非公平锁的选择</h5><p>一点源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>构造函数中选择公平锁（FairSync）、非公平锁（NonfairSync）。</li></ul><h4 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h4><ul><li><strong>非公平锁</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/25</span><br><span class="hljs-comment"> * Description 公平锁/非公平锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairLockDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">false</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    lock.unlock();<br>                &#125;<br>            &#125;, <span class="hljs-string">&quot;t&quot;</span> + i).start();<br>        &#125;<br>        <span class="hljs-comment">// 1s 之后去争抢锁</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; running...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;强行插入&quot;</span>).start();<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>强行插入，有机会在中间输出</p><p><strong>运行结果</strong></p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328200858114.png" alt="image-20230328200858114"></p><p>改为公平锁后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>强行插入，总是在最后输出</p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328200957557.png" alt="image-20230328200957557"></p><p><strong>说明</strong></p><p>开启公平锁后，所有的线程在entrylist中按照开始的时间顺序执行，不会出现插队现象，所以公平锁能够解决饥饿现象。不开启公平锁，当上一个线程结束后，随机从entrylist中执行一个线程。</p><h4 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h4><p><strong>公平锁</strong></p><ul><li>优点：吞吐率较高。</li><li>缺点：从申请者个体的角度来看，这些申请者获得相应资源的独占权所需时间的偏差可能比较大，即有的线程很快就能申请到资源，而有的线程则要经历若干次暂停与唤醒才能成功申请到资源，<code>极端情况下可能导致饥饿现象</code>。（注意：对于非公平锁：*<u>在高并发的情况下，有可能会造成优先级反转或者饥饿现象</u>*</li></ul><p><strong>非公平锁</strong></p><ul><li>优点：从个体申请者的角度来看，这些申请者获得相应资源的独占权所需时间的偏差可能比较小，即每个资源申请者申请到资源所需的时间基本相同，并且不会导致饥饿现象。</li><li>缺点：吞吐率较低，这是其维护资源独占权的授予顺序的开销比较大（主要是线程的暂停与唤醒所导致的上下文切换）的结果。</li></ul><h3 id="七、条件变量"><a href="#七、条件变量" class="headerlink" title="七、条件变量"></a>七、条件变量</h3><h4 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h4><ul><li>关键字synchronized中也有条件变量，就是waitSet，可以理解为条件不满足时进入waitSet等待，一个synchronized只能对应一个waitSet。</li><li>ReentrantLock可以支持多个条件变量，因此可以将不同条件的线程放入等待集合中，以便于后续进行专门的唤醒。在ReentrantLock中使用条件变量需要使用await()方法。</li></ul><blockquote><p>ReentrantLock的条件变量比synchronized强大之处在于，它支持多个条件变量（对象）。</p></blockquote><h5 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h5><ul><li>使用<code>ReentrantLock</code>对象创建条件变量<code>condition</code>;</li><li>执行<code>condition.await()</code>前需要先获取锁；</li><li>执行<code>condition.await()</code>后，线程会释放锁，并进入<code>conditionObject</code>中等待；</li><li>其它线程执行<code>condition.signal()</code>或者<code>condition.signalAll()</code>唤醒<code>conditionObject</code>中等待的线程；</li><li>被唤醒后会重新竞争锁</li><li>竞争锁成功后，会从await()后的代码处开始执行</li></ul><p><strong>函数<code>await()</code>调用方式</strong></p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/image-20230328202644798.png" alt="image-20230328202644798"></p><h4 id="7-2-代码示例"><a href="#7-2-代码示例" class="headerlink" title="7.2 代码示例"></a>7.2 代码示例</h4><blockquote><ul><li>t1需要等待烟过来, 否则就一直等待</li><li>t2需要等待早餐, 否则就一直等待</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/25</span><br><span class="hljs-comment"> * Description 条件变量</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.ConditionTest&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitbreakfastQueue</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigrette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasBreakfast</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 如果没有拿到锁的话, 线程就会阻塞在这, 不会向下执行</span><br>                lock.lock();<br>                <span class="hljs-keyword">while</span> (!hasCigrette) &#123;<br>                    <span class="hljs-comment">// 不满足条件就到对应的 waitSet 等待</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        waitCigaretteQueue.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;等到了它的烟&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                lock.lock();<br>                <span class="hljs-keyword">while</span> (!hasBreakfast) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        waitbreakfastQueue.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;等到了它的早餐&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>        sleep(<span class="hljs-number">1</span>);<br>        sendBreakfast();<br>        sleep(<span class="hljs-number">1</span>);<br>        sendCigarette();<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendCigarette</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;送烟来了&quot;</span>);<br>            hasCigrette = <span class="hljs-literal">true</span>;<br>            waitCigaretteQueue.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendBreakfast</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;送早餐来了&quot;</span>);<br>            hasBreakfast = <span class="hljs-literal">true</span>;<br>            waitbreakfastQueue.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">23.927</span> c.ConditionTest [main] - 送早餐来了<br><span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">23.930</span> c.ConditionTest [t2] - 等到了它的早餐<br><span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">24.931</span> c.ConditionTest [main] - 送烟来了<br><span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">24.931</span> c.ConditionTest [t1] - 等到了它的烟<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>活跃性分析</title>
    <link href="/2023/03/28/%E6%B4%BB%E8%B7%83%E6%80%A7%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/28/%E6%B4%BB%E8%B7%83%E6%80%A7%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、死锁"><a href="#一、死锁" class="headerlink" title="一、死锁"></a>一、死锁</h3><h4 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h4><ul><li><strong>互斥条件</strong>：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li><li><strong>请求和保持条件</strong>：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li><li><strong>环路等待条件</strong>：在发生死锁时，必然存在一个进程–资源的环形链。</li></ul><h4 id="死锁示例"><a href="#死锁示例" class="headerlink" title="死锁示例"></a>死锁示例</h4><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁</p><ul><li>t1 线程获得A对象锁，接下来想获取 B对象的锁</li><li>t2 线程获得B对象锁，接下来想获取 A对象的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.thread.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-24</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 死锁</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TestDeadLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDeadLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        test1();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                    log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>                    log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (B) &#123;<br>                log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>                sleep(<span class="hljs-number">0.5</span>);<br>                <span class="hljs-keyword">synchronized</span> (A) &#123;<br>                    log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>                    log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">51</span>:<span class="hljs-number">08.966</span> c.TestDeadLock [t2] - lock B<br><span class="hljs-number">21</span>:<span class="hljs-number">51</span>:<span class="hljs-number">08.966</span> c.TestDeadLock [t1] - lock A<br><span class="hljs-comment">// 无限等待</span><br></code></pre></td></tr></table></figure><h3 id="二、定位死锁"><a href="#二、定位死锁" class="headerlink" title="二、定位死锁"></a>二、定位死锁</h3><p>检测死锁可以使用<code>jconsole</code>工具，或者使用jps定位进程id，再用<code>jstack</code> 定位死锁。</p><h4 id="2-1-jconsole工具检测死锁"><a href="#2-1-jconsole工具检测死锁" class="headerlink" title="2.1 jconsole工具检测死锁"></a>2.1 jconsole工具检测死锁</h4><p><strong>（1）选择要监测死锁的进程</strong></p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1680001869248.png"></p><p><strong>（2）选择线程-&gt;点击下方检测死锁按钮</strong></p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1680001919625.png"></p><p><strong>（3）产生死锁的线程和信息</strong></p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1680001950196.png"></p><h4 id="2-2-通过jstack-命令定位死锁"><a href="#2-2-通过jstack-命令定位死锁" class="headerlink" title="2.2 通过jstack 命令定位死锁"></a>2.2 通过<code>jstack</code> 命令定位死锁</h4><p><strong>（1）通过<code>jps</code>命令定位进程id</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">D:\Codes\idea\thread_demo&gt;jps<br><span class="hljs-number">7456</span> JConsole<br><span class="hljs-number">9156</span> TestDeadLock<br><span class="hljs-number">1128</span> Launcher<br><span class="hljs-number">12264</span> Jps<br></code></pre></td></tr></table></figure><p><strong>（2）通过 <code>jstack</code> 命令定位死锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">D:\Codes\idea\thread_demo&gt;jstack <span class="hljs-number">9156</span><br></code></pre></td></tr></table></figure><p><strong>运行部分结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">...............<br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;t2&quot;</span>:<br>        at com.lilinchao.concurrent.demo_03.TestDeadLock.lambda$test1$<span class="hljs-number">1</span>(TestDeadLock.java:<span class="hljs-number">37</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d7f90678</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d7f90688</span>&gt; (a java.lang.Object)<br>        at com.lilinchao.concurrent.demo_03.TestDeadLock$$Lambda$<span class="hljs-number">2</span>/<span class="hljs-number">1416233903.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;t1&quot;</span>:<br>        at com.lilinchao.concurrent.demo_03.TestDeadLock.lambda$test1$<span class="hljs-number">0</span>(TestDeadLock.java:<span class="hljs-number">26</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0x00000000d7f90688</span>&gt; (a java.lang.Object)<br>        - locked &lt;<span class="hljs-number">0x00000000d7f90678</span>&gt; (a java.lang.Object)<br>        at com.lilinchao.concurrent.demo_03.TestDeadLock$$Lambda$<span class="hljs-number">1</span>/<span class="hljs-number">787387795.</span>run(Unknown Source)<br>        at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><ul><li><p>避免死锁要注意加锁顺序</p></li><li><p>另外如果由于某个线程进入了死循环，导致其它线程一直等待</p><p>对于这种情况 linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 <code>top -Hp</code> 进程id 来定位是哪个线程，最后再用 jstack 排查</p></li></ul><h3 id="三、哲学家就餐问题"><a href="#三、哲学家就餐问题" class="headerlink" title="三、哲学家就餐问题"></a>三、哲学家就餐问题</h3><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1680002151426.png"></p><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。</li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。</li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> site.weiyikai.concurrent.utils.Sleeper;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/24</span><br><span class="hljs-comment"> * Description 哲学家就餐问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test05</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//　尝试获得左手筷子</span><br>            <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                <span class="hljs-comment">// 尝试获得右手筷子</span><br>                <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);       <span class="hljs-comment">// 吃饭</span><br>        Sleeper.sleep(<span class="hljs-number">0.5</span>);         <span class="hljs-comment">// 思考</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> &#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.039</span> c.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.039</span> c.Philosopher [苏格拉底] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.544</span> c.Philosopher [亚里士多德] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">29.544</span> c.Philosopher [阿基米德] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">30.045</span> c.Philosopher [阿基米德] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">30.545</span> c.Philosopher [赫拉克利特] - eating...<br><span class="hljs-number">22</span>:<span class="hljs-number">54</span>:<span class="hljs-number">31.046</span> c.Philosopher [亚里士多德] - eating...<br><span class="hljs-comment">// 无限等待</span><br></code></pre></td></tr></table></figure><p><strong>使用 jconsole 检测死锁</strong></p><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1680002311417.png"></p><p>线程各自持有各自的资源无法释放。</p><p>这种线程没有按预期结束，执行不下去的情况，归类为【活跃性】问题，除了死锁以外，还有活锁和饥饿者两种情况。</p><h3 id="四、活锁"><a href="#四、活锁" class="headerlink" title="四、活锁"></a>四、活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p><blockquote><p>活锁是一种情景，当两个或多个线程不停地尝试执行某个操作，但它们的执行被彼此的操作阻塞时，就会出现活锁。例如，在一个多人游戏中，两个角色相遇，他们的行动互相阻止对方移动，最终引发活锁。</p><p>在这种情况下，两个线程可以一直卡在互相阻止对方的操作上，导致无法结束程序。解决活锁的方法是引入一些调度机制，在两个线程中有一方先停止操作，让另一方继续执行，然后再轮到其它方停止操作。这样，两个线程可以在不互相阻塞的时候完成任务，从而避免了活锁的发生。</p><p>因此，在编程时，需要遵循一些规范，避免出现活锁的情况，以保证线程的正常运行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xiaowei</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022-10-24</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 活锁</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count--;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望超过 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count++;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.041</span> c.TestLiveLock [t1] - count: <span class="hljs-number">9</span><br><span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.041</span> c.TestLiveLock [t2] - count: <span class="hljs-number">9</span><br><span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.246</span> c.TestLiveLock [t2] - count: <span class="hljs-number">10</span><br><span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.246</span> c.TestLiveLock [t1] - count: <span class="hljs-number">9</span><br><span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.447</span> c.TestLiveLock [t2] - count: <span class="hljs-number">10</span><br><span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.447</span> c.TestLiveLock [t1] - count: <span class="hljs-number">9</span><br><span class="hljs-number">23</span>:<span class="hljs-number">04</span>:<span class="hljs-number">21.652</span> c.TestLiveLock [t2] - count: <span class="hljs-number">10</span><br>......................<br></code></pre></td></tr></table></figure><p><strong>分析</strong></p><p>t1和t2两个线程，一个执行<code>count--</code>，期望减到0的时候退出循环，一个执行<code>count++</code>，期望加到20退出循环，但是永远不能都退出循环。</p><h3 id="五、饥饿"><a href="#五、饥饿" class="headerlink" title="五、饥饿"></a>五、饥饿</h3><p>很多教程中把饥饿定义为，*<u>一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束</u>*，饥饿的情况不易演示，讲读写锁时会涉及饥饿问题</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>park与unpark基本使用与原理分析</title>
    <link href="/2023/03/28/park%E4%B8%8Eunpark%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/28/park%E4%B8%8Eunpark%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>LockSupport是JDK中比较底层的类，用来创建锁和其他同步工具类的基本线程阻塞原语。</p><p>park,unpark这两个方法都是LockSupport类名下的方法，park用来暂停线程，unpark用来将暂停的线程恢复。</p><p>先park再unpark的方式是容易理解的。但还有一个场景，<strong>先unpark后再次执行park方法，也不会阻塞调用了park方法的线程</strong>。</p><p><u>理解为park方法就是校验获取一个通行令牌，而unpark方法是获取到一个通行令牌的过程。先执行unpark方法，代表先获得了通行令牌。那么在另一个线程调用park方法时，校验到这个令牌存在，消耗掉这个令牌然后就可以继续往下走。</u></p><h3 id="二、LockSupport函数列表"><a href="#二、LockSupport函数列表" class="headerlink" title="二、LockSupport函数列表"></a>二、LockSupport函数列表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupport</span> &#123;<br><br>    <span class="hljs-comment">// 返回提供给最近一次尚未解除阻塞的 park 方法调用的 blocker 对象，如果该调用不受阻塞，则返回 null。</span><br>    <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBlocker</span><span class="hljs-params">(Thread t)</span>;<br><br>    <span class="hljs-comment">// 为了线程调度，禁用当前线程，除非许可可用。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">// 为了线程调度，在许可可用之前禁用当前线程。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span>;<br><br>    <span class="hljs-comment">// 为了线程调度禁用当前线程，最多等待指定的等待时间，除非许可可用。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span>;<br><br>    <span class="hljs-comment">// 为了线程调度，在许可可用前禁用当前线程，并最多等待指定的等待时间。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span>;<br><br>    <span class="hljs-comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span>;<br><br>    <span class="hljs-comment">// 为了线程调度，在指定的时限前禁用当前线程，除非许可可用。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span>;<br><br>    <span class="hljs-comment">// 如果给定线程的许可尚不可用，则使其可用。</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>说明:LockSupport是通过调用Unsafe函数中的接口实现阻塞和解除阻塞的。</p><h4 id="park-与park-Object-blocker-区别说明"><a href="#park-与park-Object-blocker-区别说明" class="headerlink" title="park()与park(Object blocker)区别说明"></a>park()与park(Object blocker)区别说明</h4><blockquote><p>其他对应方法同样的原理，故以park()与park(Object blocker)为例进行说明</p></blockquote><p>这两个方法都是用于线程调度的，但是有所不同：</p><ol><li><code>park()</code> 方法会将当前线程挂起（暂停），直到被唤醒或者中断。</li><li><code>park(Object blocker)</code> 方法与 <code>park()</code> 方法类似，但是它还可以指定一个“阻塞器”对象，以便更好地进行调试和分析。当线程被阻塞时，阻塞器对象会被记录下来，方便程序员进行问题定位。</li></ol><p>下面是使用代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例 1: park()</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;线程开始运行&quot;</span>);<br>    LockSupport.park(); <span class="hljs-comment">// 线程被挂起</span><br>    System.out.println(<span class="hljs-string">&quot;线程被唤醒&quot;</span>);<br>&#125;);<br>thread1.start();<br><br>Thread.sleep(<span class="hljs-number">3000</span>);<br>LockSupport.unpark(thread1); <span class="hljs-comment">// 唤醒线程</span><br><br><span class="hljs-comment">// 示例 2: park(Object blocker)</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">blocker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;线程开始运行&quot;</span>);<br>    LockSupport.park(blocker); <span class="hljs-comment">// 线程被挂起，并记录阻塞器对象</span><br>    System.out.println(<span class="hljs-string">&quot;线程被唤醒&quot;</span>);<br>&#125;);<br>thread2.start();<br><br>Thread.sleep(<span class="hljs-number">3000</span>);<br>LockSupport.unpark(thread2); <span class="hljs-comment">// 唤醒线程</span><br><br><span class="hljs-comment">// 打印出阻塞器对象</span><br>System.out.println(LockSupport.getBlocker(thread2)); <span class="hljs-comment">// 输出 blocker</span><br><br></code></pre></td></tr></table></figure><p>在示例 2 中，我们使用了一个阻塞器对象 blocker，当线程被阻塞时，该对象会被记录下来。在最后一行代码中，我们打印出了线程 thread2 的阻塞器对象，输出结果为 “blocker”。</p><h3 id="三、基本使用"><a href="#三、基本使用" class="headerlink" title="三、基本使用"></a>三、基本使用</h3><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679993190960.png"></p><ul><li><strong>先 park 再 unpark</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/22</span><br><span class="hljs-comment"> * Description 先 park 再 unpark</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>            sleep(<span class="hljs-number">1</span>);<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        LockSupport.unpark(t1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">35.017</span> c.Test01 [t1] - start...<br><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">36.019</span> c.Test01 [t1] - park...<br><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">37.017</span> c.Test01 [main] - unpark...<br><span class="hljs-number">21</span>:<span class="hljs-number">16</span>:<span class="hljs-number">37.017</span> c.Test01 [t1] - resume...<br></code></pre></td></tr></table></figure><ul><li><strong>先 unpark 再 park</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.locks.LockSupport;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/22</span><br><span class="hljs-comment"> * Description 先 unpark 再 park</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test02&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>            sleep(<span class="hljs-number">2</span>);<br>            log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;resume...&quot;</span>);<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>        LockSupport.unpark(t1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">21</span>:<span class="hljs-number">18</span>:<span class="hljs-number">03.732</span> c.Test02 [t1] - start...<br><span class="hljs-number">21</span>:<span class="hljs-number">18</span>:<span class="hljs-number">04.731</span> c.Test02 [main] - unpark...<br><span class="hljs-number">21</span>:<span class="hljs-number">18</span>:<span class="hljs-number">05.735</span> c.Test02 [t1] - park...<br><span class="hljs-number">21</span>:<span class="hljs-number">18</span>:<span class="hljs-number">05.735</span> c.Test02 [t1] - resume...<br></code></pre></td></tr></table></figure><h4 id="与Object的wait¬ify对比"><a href="#与Object的wait¬ify对比" class="headerlink" title="与Object的wait¬ify对比"></a>与Object的wait¬ify对比</h4><ul><li><p>wait，notify 和 notifyAll 必须配合 <u>Object Monitor</u> 一起使用，而 park，unpark 不必；</p></li><li><p>park &amp; unpark 是<u>以线程为单位</u>来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】；</p></li><li><p>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify。</p></li></ul><h3 id="四、原理"><a href="#四、原理" class="headerlink" title="四、原理"></a>四、原理</h3><p>每个线程都会关联一个 Parker 对象，每个 Parker 对象都各自维护了三个角色：<code>_counter</code>(计数器)、 <code>_mutex</code>(互斥量)、<code>_cond</code>(条件变量)。</p><h4 id="4-1-情况一：先调用park，再调用unpark"><a href="#4-1-情况一：先调用park，再调用unpark" class="headerlink" title="4.1 情况一：先调用park，再调用unpark"></a>4.1 情况一：先调用park，再调用unpark</h4><h5 id="park-操作"><a href="#park-操作" class="headerlink" title="park 操作"></a>park 操作</h5><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679993762801.png"></p><ol><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter &#x3D; 0</li></ol><h5 id="unpark-操作"><a href="#unpark-操作" class="headerlink" title="unpark 操作"></a>unpark 操作</h5><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679993838744.png"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ol><h4 id="4-2-情况二：先调用unpark，再调用park"><a href="#4-2-情况二：先调用unpark，再调用park" class="headerlink" title="4.2 情况二：先调用unpark，再调用park"></a>4.2 情况二：先调用unpark，再调用park</h4><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679993877689.png"></p><ol><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ol>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>保护性暂停模式</title>
    <link href="/2023/03/28/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/03/28/%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p><strong>保护性暂停（Guarded Suspension）</strong>：用在一个线程等待另一个线程的执行结果时使用。</p><p>保护性暂停的暂停就是当条件不满足的时候就去进行<code>wait</code>等待。</p><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>有一个结果需要从一个线程传递到另一个线程，让它们关联同一个<code>GuardedObject</code>。</li><li>如果有结果不断从一个线程到另一个线程那么此时就不能使用这个保护性暂停模式了，可以使用*<u>消息队列</u>*(见生产者&#x2F;消费者)。</li><li>JDK中，join的实现、Future的实现，采用的就是此模式。(用join一个线程等待另一个线程结束就可以拿到结果了，其实这也是保护性线程的一个应用)</li><li>因为要等待另一方的结果，因此归类到<u><em>同步模式</em></u>。（关于同步模式的顺序控制实现见文章：<a href="https://weiyikai.site/2023/03/28/%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6%EF%BC%88%E7%AC%94%E8%AF%95%EF%BC%89/">同步模式之顺序控制</a></li></ul><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679988931052.png"></p><p>线程2产生这个结果，然后线程1想要得到这个结果，那就可以让<code>GuardedObject</code>充当一个桥梁，让线程1、2都关联到这个对象上。</p><h3 id="二、单任务版GuardedObject"><a href="#二、单任务版GuardedObject" class="headerlink" title="二、单任务版GuardedObject"></a>二、单任务版GuardedObject</h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><blockquote><p>t1 等待 t2线程的下载结果</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> site.weiyikai.concurrent.utils.Downloader;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/20</span><br><span class="hljs-comment"> * Description 单任务版GuardedObject (t1 等待 t2线程的下载结果)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.GuardedTest01&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedTest01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GuardedObject</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 等待结果</span><br>            log.debug(<span class="hljs-string">&quot;等待结果&quot;</span>);<br>            List&lt;String&gt; list = (List&lt;String&gt;) guardedObject.get();<br>            log.debug(<span class="hljs-string">&quot;结果大小：&#123;&#125;&quot;</span>, list.size());<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;执行下载&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//读取下载来的数据到List集合当中</span><br>                List&lt;String&gt; list = Downloader.download();<br>                <span class="hljs-comment">//产生结果</span><br>                guardedObject.complete(list);<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * wait/notifyAll使用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject</span> &#123;<br><br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-comment">// 获取结果(没有结果将处于一直等待状态,等待结果的产生)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 没有结果则一直等待</span><br>            <span class="hljs-comment">// 防止虚假唤醒</span><br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 给成员变量赋值</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-comment">// 产生结果，通知等待线程</span><br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Downloader代码</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.net.HttpURLConnection;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Downloader</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title function_">download</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection) <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(<span class="hljs-string">&quot;https://www.baidu.com/&quot;</span>).openConnection();<br>        List&lt;String&gt; lines = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span><br>                     <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(conn.getInputStream(), StandardCharsets.UTF_8))) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                lines.add(line);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lines;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">31.032</span> c.GuardedTest01 [t2] - 执行下载<br><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">31.032</span> c.GuardedTest01 [t1] - 等待结果<br><span class="hljs-number">23</span>:<span class="hljs-number">45</span>:<span class="hljs-number">32.409</span> c.GuardedTest01 [t1] - 结果大小：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="升级代码，设置超时时间"><a href="#升级代码，设置超时时间" class="headerlink" title="升级代码，设置超时时间"></a>升级代码，设置超时时间</h4><p>如果超过时间还没返回结果,此时就不等了，退出while循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> site.weiyikai.concurrent.utils.Sleeper;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/20</span><br><span class="hljs-comment"> * Description 带超时时间的阻塞获取结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.GuardedTest02&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedTest02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 线程1等待线程2的下载结果</span><br>        <span class="hljs-type">GuardedObjectTime</span> <span class="hljs-variable">guardeObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObjectTime</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> guardeObject.get(<span class="hljs-number">2000</span>);<br>            log.debug(<span class="hljs-string">&quot;结果是:&#123;&#125;&quot;</span>, obj);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br>            Sleeper.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 在等待时间内</span><br><span class="hljs-comment">//            Sleeper.sleep(3);//  超时的情况</span><br>            guardeObject.complete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObjectTime</span> &#123;<br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout表示等待多久</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 假如开始时间为 15:00:00</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间（假设 timeout 是 1000，结果在 400 时被唤醒了，那么还有 600 要等）</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间, 退出循环</span><br>                <span class="hljs-keyword">if</span> (waitTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 等待的时间应该 超时时间(timeout) - 经历的时间(passedTime)</span><br>                    <span class="hljs-built_in">this</span>.wait(waitTime);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果变量赋值</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>在等待时间内的运行情况</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">50</span>:<span class="hljs-number">19.739</span> c.GuardedTest02 [t1] - begin<br><span class="hljs-number">23</span>:<span class="hljs-number">50</span>:<span class="hljs-number">19.739</span> c.GuardedTest02 [t2] - begin<br><span class="hljs-number">23</span>:<span class="hljs-number">50</span>:<span class="hljs-number">20.745</span> c.GuardedTest02 [t1] - 结果是:java.lang.Object@2e10de1<br></code></pre></td></tr></table></figure><ul><li><strong>超时的情况</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">16.857</span> c.GuardedTest02 [t1] - begin<br><span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">16.857</span> c.GuardedTest02 [t2] - begin<br><span class="hljs-number">23</span>:<span class="hljs-number">52</span>:<span class="hljs-number">18.861</span> c.GuardedTest02 [t1] - 结果是:<span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="三、原理之join"><a href="#三、原理之join" class="headerlink" title="三、原理之join"></a>三、原理之join</h3><blockquote><p>t.join( )方法<strong>阻塞调用此方法的线程</strong>(calling thread)进入 TIMED_WAITING 状态，<strong>直到线程 t 执行完成，此线程再继续</strong>；</p><p>通常用于在main( )主线程内，等待其它线程完成再结束main( )主线程</p></blockquote><ul><li>调用者轮询检查线程 alive 状态</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">t1.join();<br></code></pre></td></tr></table></figure><ul><li>等价于下面的代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (t1) &#123;<br>  <span class="hljs-comment">// 调用者线程进入 t1 的 waitSet 等待, 直到 t1 运行结束</span><br>  <span class="hljs-comment">// 此处t1线程对象作为了锁</span><br>  <span class="hljs-keyword">while</span> (t1.isAlive()) &#123;<br>    <span class="hljs-comment">// 调用线程进了锁t1的waitSet</span><br>    <span class="hljs-comment">// 注意，调用线程不是t1，t1此处是作为锁而不是作为线程</span><br>    <span class="hljs-comment">// 调用线程是其他线程，一般是主线程</span><br>    t1.wait(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="join源码"><a href="#join源码" class="headerlink" title="join源码"></a>join源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                wait(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 和上面的超时增强原理一样</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                wait(delay);<br>                now = System.currentTimeMillis() - base;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><ul><li>当millis&#x3D;&#x3D;0时，会进入while( isAlive( ) )循环；即只要子线程是活的，主线程就不停的等待。</li><li>wait( )的作用是让“当前线程”等待，而这里的“当前线程”是指当前运行的线程。虽然是调用子线程的wait( )方法，但是它是通过“主线程”去调用的；所以，休眠的是主线程，而不是“子线程”！</li></ul><p>这样理解: 例子中的Thread t只是一个对象 , isAlive( )判断当前对象(例子中的t对象)是否存活, wait()阻塞的是当前执行的线程(一般是main方法)</p><p>可以看出，Join方法实现是通过wait( )。 当main线程调用t.join时候，main线程会获得线程对象t的锁（wait 意味着拿到该对象的锁)，调用该对象的wait( )，直到该对象唤醒main线程 ，比如退出后。这就意味着main 线程调用t.join时，必须能够拿到线程t对象的锁。</p><h3 id="四、多任务版-GuardedObject"><a href="#四、多任务版-GuardedObject" class="headerlink" title="四、多任务版 GuardedObject"></a>四、多任务版 GuardedObject</h3><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679991633221.png"></p><ul><li>图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类。</li><li>不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理。和生产者消费者模式的区别就是：<strong>这个产生结果的线程和使用结果的线程是一一对应的关系，但是生产者消费者模式并不是</strong>。</li><li><strong>rpc框架</strong>的调用中就使用到了这种模式。</li></ul><p><strong>示例代码</strong></p><blockquote><p><strong>送信收信案例</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> site.weiyikai.concurrent.utils.Sleeper;<br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.Hashtable;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多任务版 GuardedObject</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.GuardedTest03&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedTest03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">People</span>().start();<br>        &#125;<br>        Sleeper.sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (Integer id : Mailboxes.getIds()) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Postman</span>(id, <span class="hljs-string">&quot;内容&quot;</span> + id).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.People&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 收信</span><br>        <span class="hljs-type">GuardedObject03</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.createGuardedObject();<br>        log.debug(<span class="hljs-string">&quot;开始收信 id:&#123;&#125;&quot;</span>, guardedObject.getId());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">mail</span> <span class="hljs-operator">=</span> guardedObject.get(<span class="hljs-number">5000</span>);<br>        log.debug(<span class="hljs-string">&quot;收到信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, guardedObject.getId(), mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Postman&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Postman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String mail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Postman</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String mail)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.mail = mail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject03</span> <span class="hljs-variable">guardedObject</span> <span class="hljs-operator">=</span> Mailboxes.getGuardedObject(id);<br>        log.debug(<span class="hljs-string">&quot;送信 id:&#123;&#125;, 内容:&#123;&#125;&quot;</span>, id, mail);<br>        guardedObject.complete(mail);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Mailboxes</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer, GuardedObject03&gt; boxes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hashtable</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 产生唯一 id</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">int</span> <span class="hljs-title function_">generateId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据id得到唯一的GuardedObject,用完给到收信人得移除GuardedObject</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject03 <span class="hljs-title function_">getGuardedObject</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.remove(id);<br>    &#125;<br><br>    <span class="hljs-comment">// 产生GuardedObject</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> GuardedObject03 <span class="hljs-title function_">createGuardedObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">GuardedObject03</span> <span class="hljs-variable">go</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuardedObject03</span>(generateId());<br>        boxes.put(go.getId(), go);<br>        <span class="hljs-keyword">return</span> go;<br>    &#125;<br><br>    <span class="hljs-comment">// 得到map中的所有键，也就是id</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;Integer&gt; <span class="hljs-title function_">getIds</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> boxes.keySet();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 增加超时效果</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GuardedObject03</span> &#123;<br><br>    <span class="hljs-comment">// 标识 Guarded Object</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GuardedObject03</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-comment">// 结果</span><br>    <span class="hljs-keyword">private</span> Object response;<br><br>    <span class="hljs-comment">// 获取结果</span><br>    <span class="hljs-comment">// timeout 表示要等待多久 2000</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 开始时间 15:00:00</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>            <span class="hljs-comment">// 经历的时间</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">passedTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (response == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 这一轮循环应该等待的时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> timeout - passedTime;<br>                <span class="hljs-comment">// 经历的时间超过了最大等待时间时，退出循环</span><br>                <span class="hljs-keyword">if</span> (timeout - passedTime &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-built_in">this</span>.wait(waitTime); <span class="hljs-comment">// 虚假唤醒 15:00:01</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-comment">// 求得经历时间</span><br>                passedTime = System.currentTimeMillis() - begin; <span class="hljs-comment">// 15:00:02  1s</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> response;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 产生结果</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complete</span><span class="hljs-params">(Object response)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// 给结果成员变量赋值</span><br>            <span class="hljs-built_in">this</span>.response = response;<br>            <span class="hljs-built_in">this</span>.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">15.571</span> c.People [Thread-<span class="hljs-number">1</span>] - 开始收信 id:<span class="hljs-number">1</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">15.571</span> c.People [Thread-<span class="hljs-number">2</span>] - 开始收信 id:<span class="hljs-number">2</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">15.571</span> c.People [Thread-<span class="hljs-number">0</span>] - 开始收信 id:<span class="hljs-number">3</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">16.570</span> c.Postman [Thread-<span class="hljs-number">3</span>] - 送信 id:<span class="hljs-number">3</span>, 内容:内容<span class="hljs-number">3</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">16.570</span> c.People [Thread-<span class="hljs-number">0</span>] - 收到信 id:<span class="hljs-number">3</span>, 内容:内容<span class="hljs-number">3</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">16.570</span> c.Postman [Thread-<span class="hljs-number">4</span>] - 送信 id:<span class="hljs-number">2</span>, 内容:内容<span class="hljs-number">2</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">16.571</span> c.People [Thread-<span class="hljs-number">2</span>] - 收到信 id:<span class="hljs-number">2</span>, 内容:内容<span class="hljs-number">2</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">16.571</span> c.Postman [Thread-<span class="hljs-number">5</span>] - 送信 id:<span class="hljs-number">1</span>, 内容:内容<span class="hljs-number">1</span><br><span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">16.571</span> c.People [Thread-<span class="hljs-number">1</span>] - 收到信 id:<span class="hljs-number">1</span>, 内容:内容<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h3 id="五、异步模式之生产者-x2F-消费者"><a href="#五、异步模式之生产者-x2F-消费者" class="headerlink" title="五、异步模式之生产者&#x2F;消费者"></a>五、异步模式之生产者&#x2F;消费者</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><ul><li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应(一个生产一个消费)</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679992336028.png"></p><p><strong>与保护性暂停的共同点</strong>：都是在多个线程之间进行数据传输；</p><p>异步模式中, 生产者产生消息之后消息没有被立刻消费<br>同步模式中, 消息在产生之后被立刻消费了。</p><p><strong>示例</strong></p><blockquote><p>线程间通信的消息队列</p><p>注：只是简单实现，功能很基础，了解核心原理即刻</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> site.weiyikai.concurrent.utils.Sleeper.sleep;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created by xiaowei</span><br><span class="hljs-comment"> * Date 2022/10/20</span><br><span class="hljs-comment"> * Description 生产者和消费者示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Test04&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//1.确定消息队列容量</span><br>        <span class="hljs-type">MessageQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueue</span>(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">//2.生产者线程</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-type">int</span> id=i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(id,<span class="hljs-string">&quot;值&quot;</span>+id));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;,<span class="hljs-string">&quot;生产者&quot;</span>+i).start();<br>        &#125;<br><br><br>        <span class="hljs-comment">//3.消费者线程</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-comment">//3.1每隔1s取一条消息</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    sleep(<span class="hljs-number">2</span>);<br>                    <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> queue.take();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;消费者&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息队列类，java线程之间通信</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.MessageQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageQueue</span>&#123;<br>    <span class="hljs-comment">//1.消息队列集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Message&gt; list=<span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">//2.规定容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br><br>    <span class="hljs-comment">//3.通过构造方法规定消息队列容量</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">//4.获取消息</span><br>    <span class="hljs-keyword">public</span> Message <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (list) &#123;<br>            <span class="hljs-comment">//4.1判断队列是否为空</span><br>            <span class="hljs-keyword">while</span> (list.isEmpty()) &#123;<br>                log.debug(<span class="hljs-string">&quot;队列为空，消费者线程等待&quot;</span>);<br>                list.wait();<br>            &#125;<br>            <span class="hljs-comment">//4.2取出队列中头元素并且返回</span><br>            <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> list.removeFirst();<br>            log.debug(<span class="hljs-string">&quot;已消费一个信息&quot;</span>);<br>            <span class="hljs-comment">//4.3元素取出一个后需要告诉元素-1</span><br>            list.notifyAll();<br>            <span class="hljs-keyword">return</span> message;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//5.存入消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Message message)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (list)&#123;<br>            <span class="hljs-comment">//5.1检查队列容量是否满？</span><br>            <span class="hljs-keyword">while</span>(list.size()==capcity)&#123;<br>                log.debug(<span class="hljs-string">&quot;队列已满，生产者线程等待&quot;</span>);<br>                list.wait();<br>            &#125;<br>            <span class="hljs-comment">//5.2将消息加入队列尾部</span><br>            list.addLast(message);<br>            log.debug(<span class="hljs-string">&quot;已生产一个信息&quot;</span>);<br>            list.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 邮件类，里面放邮件内容及对应id</span><br><span class="hljs-comment"> * ——&gt;为了实现安全，不能set（只能通过构造方法赋初值）只能get</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> Object value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Message</span><span class="hljs-params">(<span class="hljs-type">int</span> id, Object value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Message&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;id=&quot;</span> + id +<br>                <span class="hljs-string">&quot;, value=&quot;</span> + value +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">23.322</span> c.MessageQueue [生产者<span class="hljs-number">0</span>] - 已生产一个信息<br><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">23.324</span> c.MessageQueue [生产者<span class="hljs-number">2</span>] - 已生产一个信息<br><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">23.324</span> c.MessageQueue [生产者<span class="hljs-number">1</span>] - 队列已满，生产者线程等待<br><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">25.321</span> c.MessageQueue [消费者] - 已消费一个信息<br><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">25.321</span> c.MessageQueue [生产者<span class="hljs-number">1</span>] - 已生产一个信息<br><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">27.322</span> c.MessageQueue [消费者] - 已消费一个信息<br><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">29.323</span> c.MessageQueue [消费者] - 已消费一个信息<br><span class="hljs-number">00</span>:<span class="hljs-number">23</span>:<span class="hljs-number">31.323</span> c.MessageQueue [消费者] - 队列为空，消费者线程等待<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wait nofity</title>
    <link href="/2023/03/27/wait-nofity/"/>
    <url>/2023/03/27/wait-nofity/</url>
    
    <content type="html"><![CDATA[<h3 id="一、原理"><a href="#一、原理" class="headerlink" title="一、原理"></a>一、原理</h3><p><img src="https://wyk200341.oss-cn-hangzhou.aliyuncs.com/img/1679902042459.png"></p><p><strong>分析</strong></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态</li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片</li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒</li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争</li></ul><h3 id="二、API介绍"><a href="#二、API介绍" class="headerlink" title="二、API介绍"></a>二、API介绍</h3><table><thead><tr><th><strong>方法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>obj.wait()</strong></td><td>wait方法让进入object监视器的线程到waitSet等待。wait后会释放对象锁，让其他线程竞争。</td></tr><tr><td><strong>obj.wait(Long timeout)</strong></td><td>限时等待。导致当前的线程等待，等待被其他线程唤醒，或者指定的时间timeout用完，线程不再等待。</td></tr><tr><td><strong>obj.notify()</strong></td><td>在 object 上正在<code>waitSet</code> 等待的线程中挑一个唤醒。</td></tr><tr><td><strong>obj.notifyAll()</strong></td><td>让 object 上正在 <code>waitSet</code> 等待的线程全部唤醒。</td></tr></tbody></table><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestWaitNotify&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestWaitNotify</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>                log.debug(<span class="hljs-string">&quot;执行...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    obj.wait(); <span class="hljs-comment">//让线程在obj上一直等待下去</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;其它代码...&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (obj)&#123;<br>                log.debug(<span class="hljs-string">&quot;执行...&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    obj.wait(); <span class="hljs-comment">//让线程在obj上一直等待下去</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;其它代码...&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br><br>        <span class="hljs-comment">//主线程两秒后执行</span><br>        sleep(<span class="hljs-number">2</span>);<br>        log.debug(<span class="hljs-string">&quot;唤醒 obj 上其它线程&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>            obj.notify(); <span class="hljs-comment">// 唤醒obj上一个线程</span><br><span class="hljs-comment">//            obj.notifyAll(); // 唤醒obj上所有等待线程</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>notify运行结果</strong></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">22:36:43.159 c.TestWaitNotify [t1] - 执行...</span><br><span class="hljs-section">22:36:43.161 c.TestWaitNotify [t2] - 执行...</span><br><span class="hljs-section">22:36:45.171 c.TestWaitNotify [main] - 唤醒 obj 上其它线程</span><br><span class="hljs-section">22:36:45.171 c.TestWaitNotify [t1] - 其它代码...</span><br></code></pre></td></tr></table></figure><ul><li><strong>notifyAll运行结果</strong></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">22:39:49.383 c.TestWaitNotify [t1] - 执行...</span><br><span class="hljs-section">22:39:49.385 c.TestWaitNotify [t2] - 执行...</span><br><span class="hljs-section">22:39:51.389 c.TestWaitNotify [main] - 唤醒 obj 上其它线程</span><br><span class="hljs-section">22:39:51.389 c.TestWaitNotify [t2] - 其它代码...</span><br><span class="hljs-section">22:39:51.389 c.TestWaitNotify [t1] - 其它代码...</span><br></code></pre></td></tr></table></figure><p><code>wait()</code> 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到 notify 为止。</p><p><code>wait(long n)</code> 有时限的等待, 到 n 毫秒后结束等待，或是被 notify。</p><h3 id="三、wait-notify的正确姿势"><a href="#三、wait-notify的正确姿势" class="headerlink" title="三、wait notify的正确姿势"></a>三、wait notify的正确姿势</h3><h4 id="3-1-sleep-long-n-和-wait-long-n-的区别"><a href="#3-1-sleep-long-n-和-wait-long-n-的区别" class="headerlink" title="3.1 sleep(long n) 和 wait(long n) 的区别"></a>3.1 sleep(long n) 和 wait(long n) 的区别</h4><ul><li>sleep 是 Thread 的方法，而 wait 是 Object 的方法</li><li>sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用</li><li>sleep 在睡眠的同时，不会释放对象锁，但 wait 在等待的时候会释放对象锁</li><li>无时限wait方法执行后线程变为WAITING状态，有时限的wait方法与sleep方法执行后变为TIMED_WAITING状态</li></ul><h4 id="3-2-演变步骤"><a href="#3-2-演变步骤" class="headerlink" title="3.2 演变步骤"></a>3.2 演变步骤</h4><h5 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCorrectPostureStep1</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">//有没有烟</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没?[&#123;&#125;]&quot;</span>,hasCigarette);<br>                <span class="hljs-keyword">if</span>(!hasCigarette)&#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟,先歇会!&quot;</span>);<br>                    sleep(<span class="hljs-number">2</span>);<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没?[&#123;&#125;]&quot;</span>,hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette)&#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Leefs&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;,<span class="hljs-string">&quot;其他人&quot;</span>).start();<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                hasCigarette = <span class="hljs-literal">true</span>;<br>                log.debug(<span class="hljs-string">&quot;烟到了!&quot;</span>);<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">22:50:16.626 c.TestCorrectPostureStep1 [Leefs] - 有烟没?[false]</span><br><span class="hljs-section">22:50:16.628 c.TestCorrectPostureStep1 [Leefs] - 没烟,先歇会!</span><br>---------- 中间间隔2s -------<br><span class="hljs-section">22:50:18.638 c.TestCorrectPostureStep1 [Leefs] - 有烟没?[false]</span><br><span class="hljs-section">22:50:18.638 c.TestCorrectPostureStep1 [送烟的] - 烟到了!</span><br><span class="hljs-section">22:50:18.638 c.TestCorrectPostureStep1 [其他人] - 可以开始干活了</span><br><span class="hljs-section">22:50:18.638 c.TestCorrectPostureStep1 [其他人] - 可以开始干活了</span><br><span class="hljs-section">22:50:18.638 c.TestCorrectPostureStep1 [其他人] - 可以开始干活了</span><br><span class="hljs-section">22:50:18.639 c.TestCorrectPostureStep1 [其他人] - 可以开始干活了</span><br><span class="hljs-section">22:50:18.639 c.TestCorrectPostureStep1 [其他人] - 可以开始干活了</span><br></code></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li>通过sleep方法来使线程处于等待状态；</li><li>【Leefs线程】必须睡足2s后才能醒来，就算烟提前送到，也无法立刻醒来；</li><li>如果送烟的线程也加了 synchronized (room) 后，就好比【Leefs】在里面反锁了门睡觉，烟根本没法送进门，main 没加synchronized 就好像 main 线程是翻窗户进来的；</li><li>当【Leefs线程】获得锁在睡眠时，其它干活的线程，都要一直阻塞，效率太低；</li><li>解决方法，使用 wait - notify 机制。</li></ul><h5 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCorrectPostureStep2</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没?[&#123;&#125;]&quot;</span>,hasCigarette);<br>                <span class="hljs-keyword">if</span>(!hasCigarette)&#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟,先歇会!&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait(<span class="hljs-number">2000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span>(hasCigarette)&#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Leefs&quot;</span>).start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125;<br>            &#125;,<span class="hljs-string">&quot;其他人&quot;</span>).start();<br>        &#125;<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                hasCigarette = <span class="hljs-literal">true</span>;<br>                log.debug(<span class="hljs-string">&quot;烟到了!&quot;</span>);<br>                room.notify();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">23:05:18.333 c.TestCorrectPostureStep2 [Leefs] - 有烟没?[false]</span><br><span class="hljs-section">23:05:18.336 c.TestCorrectPostureStep2 [Leefs] - 没烟,先歇会!</span><br><span class="hljs-section">23:05:18.336 c.TestCorrectPostureStep2 [其他人] - 可以开始干活了</span><br><span class="hljs-section">23:05:18.336 c.TestCorrectPostureStep2 [其他人] - 可以开始干活了</span><br><span class="hljs-section">23:05:18.336 c.TestCorrectPostureStep2 [其他人] - 可以开始干活了</span><br><span class="hljs-section">23:05:18.336 c.TestCorrectPostureStep2 [其他人] - 可以开始干活了</span><br><span class="hljs-section">23:05:18.336 c.TestCorrectPostureStep2 [其他人] - 可以开始干活了</span><br><span class="hljs-section">23:05:19.342 c.TestCorrectPostureStep2 [送烟的] - 烟到了!</span><br><span class="hljs-section">23:05:19.343 c.TestCorrectPostureStep2 [Leefs] - 有烟没？[true]</span><br><span class="hljs-section">23:05:19.343 c.TestCorrectPostureStep2 [Leefs] - 可以开始干活了</span><br></code></pre></td></tr></table></figure><ul><li>解决了当【Leefs线程】处于睡眠状态时，其他线程可以获取锁不需等待释放锁的问题</li><li>但如果有其它线程也在等待条件呢？送烟的主线程notify会不会错误地叫醒其他线程呢？</li></ul><h5 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCorrectPostureStep3</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Leefs&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没?[&#123;&#125;]&quot;</span>,hasTakeout);<br>                <span class="hljs-keyword">if</span>(!hasTakeout)&#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Jeyoo&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                hasTakeout = <span class="hljs-literal">true</span>;<br>                log.debug(<span class="hljs-string">&quot;外卖送到了!&quot;</span>);<br>                room.notify();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">23:12:26.760 c.TestCorrectPostureStep3 [Leefs] - 有烟没？[false]</span><br><span class="hljs-section">23:12:26.762 c.TestCorrectPostureStep3 [Leefs] - 没烟，先歇会！</span><br><span class="hljs-section">23:12:27.766 c.TestCorrectPostureStep3 [Jeyoo] - 外卖送到没?[false]</span><br><span class="hljs-section">23:12:27.766 c.TestCorrectPostureStep3 [Jeyoo] - 没外卖，先歇会！</span><br><span class="hljs-section">23:12:28.771 c.TestCorrectPostureStep3 [送外卖的] - 外卖送到了!</span><br><span class="hljs-section">23:12:28.772 c.TestCorrectPostureStep3 [Leefs] - 有烟没？[false]</span><br><span class="hljs-section">23:12:28.773 c.TestCorrectPostureStep3 [Leefs] - 没干成活...</span><br></code></pre></td></tr></table></figure><ul><li>notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】</li><li>解决方法，改为 notifyAll</li></ul><h5 id="step-4"><a href="#step-4" class="headerlink" title="step 4"></a>step 4</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestCorrectPostureStep4&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCorrectPostureStep4</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">if</span> (hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Leefs&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room)&#123;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没?[&#123;&#125;]&quot;</span>,hasTakeout);<br>                <span class="hljs-keyword">if</span>(!hasTakeout)&#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        room.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">if</span> (hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;没干成活...&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;Jeyoo&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (room) &#123;<br>                hasTakeout = <span class="hljs-literal">true</span>;<br>                log.debug(<span class="hljs-string">&quot;外卖送到了!&quot;</span>);<br>                room.notifyAll();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">10:42:37.796 c.TestCorrectPostureStep5 [Leefs] - 有烟没？[false]</span><br><span class="hljs-section">10:42:37.798 c.TestCorrectPostureStep5 [Leefs] - 没烟，先歇会！</span><br><span class="hljs-section">10:42:38.801 c.TestCorrectPostureStep5 [Jeyoo] - 外卖送到没?[false]</span><br><span class="hljs-section">10:42:38.801 c.TestCorrectPostureStep5 [Jeyoo] - 没外卖，先歇会！</span><br><span class="hljs-section">10:42:39.809 c.TestCorrectPostureStep5 [送外卖的] - 外卖送到了!</span><br><span class="hljs-section">10:42:39.810 c.TestCorrectPostureStep5 [Jeyoo] - 外卖送到没？[true]</span><br><span class="hljs-section">10:42:39.810 c.TestCorrectPostureStep5 [Jeyoo] - 可以开始干活了</span><br><span class="hljs-section">10:42:39.810 c.TestCorrectPostureStep5 [Leefs] - 没烟，先歇会！</span><br></code></pre></td></tr></table></figure><ul><li>用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了</li><li>解决方法，用 while + wait，当条件不成立，再次 wait</li></ul><h5 id="step-5"><a href="#step-5" class="headerlink" title="step 5"></a>step 5</h5><p>将 if 改为 while</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!hasCigarette) &#123;<br>    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        room.wait();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改动后</p><ul><li>wait方法被唤醒后才会执行后面代码，因此此处不会导致while循环空转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!hasCigarette) &#123;<br>    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        room.wait();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">23:20:07.016 c.TestCorrectPostureStep5 [Leefs] - 有烟没？[false]</span><br><span class="hljs-section">23:20:07.019 c.TestCorrectPostureStep5 [Leefs] - 没烟，先歇会！</span><br><span class="hljs-section">23:20:08.030 c.TestCorrectPostureStep5 [Jeyoo] - 外卖送到没?[false]</span><br><span class="hljs-section">23:20:08.031 c.TestCorrectPostureStep5 [Jeyoo] - 没外卖，先歇会！</span><br><span class="hljs-section">23:20:09.033 c.TestCorrectPostureStep5 [送外卖的] - 外卖送到了!</span><br><span class="hljs-section">23:20:09.034 c.TestCorrectPostureStep5 [Jeyoo] - 外卖送到没？[true]</span><br><span class="hljs-section">23:20:09.034 c.TestCorrectPostureStep5 [Jeyoo] - 可以开始干活了</span><br><span class="hljs-section">23:20:09.034 c.TestCorrectPostureStep5 [Leefs] - 没烟，先歇会！</span><br></code></pre></td></tr></table></figure><h3 id="总结：正确姿势"><a href="#总结：正确姿势" class="headerlink" title="总结：正确姿势"></a>总结：正确姿势</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>  <span class="hljs-keyword">while</span>(条件不成立) &#123;<br>    lock.wait();<br>  &#125;<br>  <span class="hljs-comment">// 干活</span><br>&#125;<br><br><span class="hljs-comment">//另一个线程</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>  lock.notifyAll();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>synchronized原理进阶</title>
    <link href="/2023/03/27/synchronized%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/03/27/synchronized%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、轻量级锁"><a href="#一、轻量级锁" class="headerlink" title="一、轻量级锁"></a>一、轻量级锁</h3><p><strong>轻量级锁的使用场景：</strong>如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。</p><p>轻量级锁对使用者是透明的，即语法仍然是 <code>synchronized</code></p><p><strong>示例</strong></p><p>假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        <span class="hljs-comment">// 同步块 A</span><br>        method2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        <span class="hljs-comment">// 同步块 B</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>图解加锁过程</strong></p><ul><li>1、创建锁记录(Lock Record)对象,每个线程的<strong>栈帧</strong>都会包含一个锁记录的结构，内部可以存储锁定对象的<code>Mark Word</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679900570513.png"></p><ul><li><p>2、让锁记录中<code>Object reference</code>指向锁对象，并尝试用cas替换Object的Mark Word,将Mark Word的值存入锁记录</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679900617925.png"></p></li></ul><blockquote><p>CAS（Compare and Swap）:JDK提供的非阻塞原子性操作，它通过硬件保证了比较——更新操作的原子性。</p></blockquote><ul><li>3、如果<code>cas</code>(compare and swap)替换成功，对象头中存储了<code>锁记录地址和状态00</code>，表示由该线程给对象加锁</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679897001018.png"></p><p><strong>线程中的锁信息和锁对象中的Mark Word进行了互换</strong></p><ul><li><p>4、如果 cas 失败，有两种情况</p><ul><li><p>如果是其它线程已经持有了该 Object 的<strong>轻量级锁</strong>，这时表明有竞争，进入锁膨胀过程；</p></li><li><p>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数（如下图所示）。</p><ul><li><p>轻量级锁示例代码中t0执行<code>syn method1(obj)</code>，获得锁之后继续调用<code>syn method2(obj)</code>（多出来一个栈帧，见下图），两个加锁的<code>obj</code>是同一个对象，因此<code>CAS</code>失败</p></li><li><p>在图中的体现：对象头<code>lock record 地址 00</code>在调用<code>method1(obj)</code>改变了，指向的是第一个栈帧的锁记录，因此第二个栈帧会CAS失败</p></li><li><p><code>Lock Record</code>的null记录锁重入的计数，如上为1，再调用一次++</p></li></ul></li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679897118895.png"></p><ul><li>5、当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679897168328.png"></p><ul><li><p>6、当退出synchronized代码块(解锁时) 锁记录的值不为null,这时使用cas将Mark Word的值恢复给对象头</p><ul><li><p>成功，则解锁成功</p></li><li><p>失败，说明轻量级锁进行了<strong>锁膨胀</strong>或已经升级为重量级锁，进入重量级锁解锁流程</p></li></ul></li></ul><h3 id="二、锁膨胀"><a href="#二、锁膨胀" class="headerlink" title="二、锁膨胀"></a>二、锁膨胀</h3><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行<code>锁膨胀</code>，将轻量级锁变为重量级锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        <span class="hljs-comment">// 同步块</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>1、当Thread-1进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679897392855.png"></p><ul><li>2、这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址；</li><li>然后自己进入 Monitor 的 <code>EntryList BLOCKED</code>。</li></ul></li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679897426505.png"></p><ul><li><p>3、当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入</p><p><strong>重量级解锁流程</strong></p><ul><li>即按照 Monitor 地址找到 Monitor 对象</li><li>设置 Owner 为 null</li><li>唤醒 <code>EntryList</code> 中 BLOCKED 线程</li></ul></li></ul><h3 id="三、自旋优化"><a href="#三、自旋优化" class="headerlink" title="三、自旋优化"></a>三、自旋优化</h3><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p><p><strong>自旋定义</strong></p><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</p><h4 id="自旋重试成功的情况"><a href="#自旋重试成功的情况" class="headerlink" title="自旋重试成功的情况"></a>自旋重试成功的情况</h4><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679897616634.png"></p><p><em>注意：自旋需要cpu资源，所以适合多核cpu</em></p><h4 id="自旋重试失败的情况"><a href="#自旋重试失败的情况" class="headerlink" title="自旋重试失败的情况"></a>自旋重试失败的情况</h4><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679897677085.png"></p><ul><li>自旋会占用 CPU 时间，<strong>单核 CPU 自旋就是浪费</strong>，多核 CPU 自旋才能发挥优势。</li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</li><li><strong>Java 7 之后不能控制是否开启自旋功能</strong></li></ul><h4 id="对于自旋优化的理解"><a href="#对于自旋优化的理解" class="headerlink" title="对于自旋优化的理解"></a>对于自旋优化的理解</h4><ul><li>在Java中，<strong>自旋优化和阻塞</strong>是两种不同的线程等待策略。</li></ul><p><strong>阻塞</strong>是指一个线程在等待某个操作完成时，会被挂起，直到操作完成才会被唤醒。这种等待方式会导致线程上下文的切换，从而降低程序的性能。</p><p><strong>自旋优化</strong>是指一个线程在等待某个操作完成时，会不断地进行忙等待，即循环检查操作是否完成，直到操作完成才会退出循环。这种等待方式可以避免线程上下文的切换，从而提高程序的性能。自旋优化通常适用于等待时间较短的情况，因为长时间的自旋会占用CPU资源，导致其他线程无法得到执行。</p><p>在Java中，自旋优化通常是通过synchronized关键字实现的。当一个线程尝试获取一个被锁定的对象时，如果该对象已经被其他线程锁定，那么该线程会进行自旋等待，直到该对象被释放为止。</p><h3 id="四、偏向锁概念"><a href="#四、偏向锁概念" class="headerlink" title="四、偏向锁概念"></a>四、偏向锁概念</h3><p>轻量级锁在<strong>没有竞争</strong>时(就自己这个线程)，每次重入仍然需要执行 CAS操作。</p><p>Java 6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。</p><ul><li><strong>升级为轻量级锁的情况 (会进行偏向锁撤销)</strong> : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作成功了, 此时该线程就获得了锁对象。( 此时是交替访问临界区, 撤销偏向锁, 升级为轻量级锁)。</li><li><strong>升级为重量级锁的情况 (会进行偏向锁撤销)</strong> : 获取偏向锁的时候, 发现线程ID不是自己的, 此时通过CAS替换操作, 操作失败了, 此时说明发生了锁竞争。( 此时是多线程访问临界区, 撤销偏向锁, 升级为重量级锁)。</li></ul><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">//同步块A</span><br>        m2();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">//同步块B</span><br>        m3();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">m3</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span>( obj ) &#123;<br>        <span class="hljs-comment">//同步块C</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679898194980.png"></p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679898228352.png"></p><h3 id="五、偏向状态"><a href="#五、偏向状态" class="headerlink" title="五、偏向状态"></a>五、偏向状态</h3><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679898298970.png"></p><p><strong>状态说明</strong></p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679898349119.png"></p><p><strong>一个对象创建时：</strong></p><ul><li>如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 <code>0x05</code> 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0</li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 <code>- XX:BiasedLockingStartupDelay=0</code> 来禁用延迟</li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，<strong>第一次用到 hashcode 时才会赋值</strong></li></ul><h5 id="（1）测试偏向锁"><a href="#（1）测试偏向锁" class="headerlink" title="（1）测试偏向锁"></a>（1）测试偏向锁</h5><ul><li>利用jol第三方工具来查看对象头信息(注意这里扩展了jol让它输出更为简洁)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添如虚拟机参数-XX:BiasedLockingStartupDelay=0</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    <span class="hljs-type">ClassLayout</span> <span class="hljs-variable">classLayout</span> <span class="hljs-operator">=</span> ClassLayout.lparseInstance(d);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;synchronized前&quot;</span>);<br>        System.out.println(classLayout.toPrintableSimple(<span class="hljs-literal">true</span>));<br>        <span class="hljs-keyword">synchronized</span> (d) &#123;<br>            log.debug(<span class="hljs-string">&quot;synchronized中&quot;</span>);<br>            System.out.println(classlayout.toPrintableSimple(<span class="hljs-literal">true</span>));<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot; synchraoized后&quot;</span>);<br>        System.out.println(classLayout.toPrintablesimple(<span class="hljs-literal">true</span>));<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:08:<span class="hljs-number">58.117</span> c. TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 前<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000101</span><br><span class="hljs-number">11</span>:08:<span class="hljs-number">58.121</span> C. TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 中<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">11010000</span> <span class="hljs-number">00000101</span><br><span class="hljs-number">11</span>:08:<span class="hljs-number">58.121</span> C. TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 后<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">11010000</span> <span class="hljs-number">00000101</span><br></code></pre></td></tr></table></figure><blockquote><p>注意</p><p>处于偏向锁的对象解锁后，线程 id 仍存储于对象头中</p></blockquote><h5 id="（2）测试禁用"><a href="#（2）测试禁用" class="headerlink" title="（2）测试禁用"></a>（2）测试禁用</h5><p>在上面测试代码运行时在添加 VM 参数 <code>-XX:-UseBiasedLocking</code> 禁用偏向锁</p><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.018</span> c.TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 前<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.021</span> C. TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 中<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">00010100</span> <span class="hljs-number">11110011</span> <span class="hljs-number">10001000</span><br><span class="hljs-number">11</span>:<span class="hljs-number">13</span>:<span class="hljs-number">10.021</span> C. TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 后<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br></code></pre></td></tr></table></figure><p>注意：最后三位001表示没有加偏向锁，最后两位00表示加了轻量级锁</p><p>说明偏向锁禁用成功！</p><h5 id="（3）测试hasecode"><a href="#（3）测试hasecode" class="headerlink" title="（3）测试hasecode"></a>（3）测试hasecode</h5><ul><li>正常状态对象一开始是没有 hashCode 的，第一次调用才生成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    d.hashcode();<span class="hljs-comment">//调用对象hashcode，使得偏向锁禁用</span><br>    <span class="hljs-type">ClassLayout</span> <span class="hljs-variable">classLayout</span> <span class="hljs-operator">=</span> ClassLayout.lparseInstance(d);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;synchronized前&quot;</span>);<br>        System.out.println(classLayout.toPrintableSimple(<span class="hljs-literal">true</span>));<br>        <span class="hljs-keyword">synchronized</span> (d) &#123;<br>            log.debug(<span class="hljs-string">&quot;synchronized中&quot;</span>);<br>            System.out.println(classlayout.toPrintableSimple(<span class="hljs-literal">true</span>));<br>        &#125;<br>        log.debug(<span class="hljs-string">&quot; synchraoized后&quot;</span>);<br>        System.out.println(classLayout.toPrintablesimple(<span class="hljs-literal">true</span>));<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679898298970.png"></p><p>观察如上的MarkWord格式，Normal下的hashcode占31位，Biased下的thread:54位，无法在装下31位的hashcode。所以，<strong>可偏向对象调了hashcode()后撤销偏向状态</strong></p><blockquote><p>轻量级锁：hashcode会存到线程栈帧的锁记录(lock Record)中</p><p>重量级锁：hashcode会存到monitor对象中</p></blockquote><h3 id="六、偏向锁撤销场景"><a href="#六、偏向锁撤销场景" class="headerlink" title="六、偏向锁撤销场景"></a>六、偏向锁撤销场景</h3><h4 id="6-1-调用对象haseCode"><a href="#6-1-调用对象haseCode" class="headerlink" title="6.1 调用对象haseCode"></a>6.1 调用对象haseCode</h4><p>调用了对象的hashCode，但偏向锁的对象MarkWord中存储的是线程id，如果调用hashCode会导致偏向锁被撤销</p><ul><li>轻量级锁会在锁记录中记录hashCode</li><li>重量级锁会在Monitor中记录hashCode</li></ul><p>在调用hashCode后使用偏向锁，记得去掉<code>-XX: -UseBiasedLocking</code></p><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.386</span> c.TestBiased [main] - 调用hashCode: <span class="hljs-number">1778535015</span><br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.391</span> c.TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 前<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">01101010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">01001010</span> <span class="hljs-number">01100111</span> <span class="hljs-number">00000001</span> 正常状态，没有偏向锁<br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.393</span> C. TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 中<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">11000011</span> <span class="hljs-number">11110011</span> <span class="hljs-number">01101000</span> 加了轻量级锁<br><span class="hljs-number">11</span>:<span class="hljs-number">22</span>:<span class="hljs-number">10.393</span> c.TestBiased [t1] - <span class="hljs-keyword">synchronized</span> 后<br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">01101010</span> <span class="hljs-number">00000010</span> <span class="hljs-number">01001010</span> <span class="hljs-number">01100111</span> <span class="hljs-number">00000001</span> 撤销 正常状态，没有偏向锁<br></code></pre></td></tr></table></figure><h4 id="6-2-其它线程使用对象"><a href="#6-2-其它线程使用对象" class="headerlink" title="6.2 其它线程使用对象"></a>6.2 其它线程使用对象</h4><p><strong>偏向锁、轻量级锁的使用条件, 都是在于多个线程没有对同一个对象进行<code>锁竞争</code>的前提下, 如果有<code>锁竞争</code>,此时就使用重量级锁。</strong></p><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (d) &#123;<br>            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;<br>            TestBiased.class.notify();<br>        &#125;<br>        <br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">synchronized</span> (TestBiased.class) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TestBiased.class.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>        <span class="hljs-keyword">synchronized</span> (d) &#123;<br>            <span class="hljs-comment">//因为t1线程已经释放了d对象锁，所以没有发生锁的竞争，只是升级为轻量级锁</span><br>            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>        &#125;<br>        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>    t2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[t1] - <span class="hljs-number">0000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">0000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">01000001</span>  <span class="hljs-number">00010000</span>  <span class="hljs-number">00000101</span> <span class="hljs-comment">//偏向锁</span><br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">0000000</span> <span class="hljs-number">0000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">01000001</span>  <span class="hljs-number">00010000</span>  <span class="hljs-number">00000101</span> <span class="hljs-comment">//偏向锁</span><br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">0000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">0000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">10110101</span>  <span class="hljs-number">11110000</span>  <span class="hljs-number">01000000</span> <span class="hljs-comment">//撤销偏向锁，改为轻量级锁，保留线程id</span><br>[t2] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span> <span class="hljs-comment">//恢复正常</span><br></code></pre></td></tr></table></figure><h4 id="6-3-调用wait-x2F-notify"><a href="#6-3-调用wait-x2F-notify" class="headerlink" title="6.3 调用wait&#x2F;notify"></a>6.3 调用wait&#x2F;notify</h4><p>wait&#x2F;notify只有重锁才有，任何线程对象调用其时，会升级为<strong>重锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>        <span class="hljs-keyword">synchronized</span> (d) &#123;<br>            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>            <span class="hljs-keyword">try</span> &#123;<br>                d.wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>    t1.start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">6000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">synchronized</span> (d) &#123;<br>            log.debug(<span class="hljs-string">&quot;notify&quot;</span>);<br>            d.notify();<br>        &#125;<br>    &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000101</span><br>[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">10110011</span> <span class="hljs-number">11111000</span> <span class="hljs-number">00000101</span><br>[t2] - notify<br>[t1] - <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011100</span> <span class="hljs-number">11010100</span> <span class="hljs-number">00001101</span> <span class="hljs-number">11001010</span><br></code></pre></td></tr></table></figure><h3 id="七、批量重偏向"><a href="#七、批量重偏向" class="headerlink" title="七、批量重偏向"></a>七、批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID。</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至加锁线程</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//</span><br>        Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>                <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>                list.add(d);<br>                <span class="hljs-keyword">synchronized</span> (d) &#123;<br>                    log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                list.notify();<span class="hljs-comment">//唤醒list</span><br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (list) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    list.wait();<span class="hljs-comment">//阻塞list，释放锁</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;===========&gt; &quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>                <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> list.get(i);<br>                log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintablesimple(<span class="hljs-literal">true</span>));<br>                <span class="hljs-keyword">synchronized</span> (d) &#123;<br>                    log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintablesimple(<span class="hljs-literal">true</span>));<br>                &#125;<br>                    log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx 线程id    线程id   线程id    加锁状态<br>[t1] - <span class="hljs-number">0</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br>[t1] - <span class="hljs-number">1</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br>[t1] - <span class="hljs-number">2</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br>[t1] - <span class="hljs-number">3</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br>[t1] - <span class="hljs-number">4</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br>[t1] - <span class="hljs-number">5</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br><br>...t1 从<span class="hljs-number">1</span>到<span class="hljs-number">29</span>都是加的线程id（<span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span>）偏向锁，状态看最后<span class="hljs-number">101</span><br><br>[t2] - ============&gt;<br>[t2] - <span class="hljs-number">0</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span> <span class="hljs-comment">//原始t1的偏向锁状态</span><br>[t2] - <span class="hljs-number">0</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01111010</span> <span class="hljs-number">11110110</span> <span class="hljs-number">01110000</span> <span class="hljs-comment">//撤销偏向锁，升级轻量级锁</span><br>[t2] - <span class="hljs-number">0</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><span class="hljs-comment">//解锁后，变为不可偏向状态</span><br>[t2] - <span class="hljs-number">1</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br>[t2] - <span class="hljs-number">1</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00100000</span> <span class="hljs-number">01111010</span> <span class="hljs-number">11110110</span> <span class="hljs-number">01110000</span><br>[t2] - <span class="hljs-number">1</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000001</span><br>...<br><span class="hljs-comment">//我们发现，到了第20个的时候（从0算第1个），又变成了偏向锁状态，但是偏向的id变成了t2了</span><br><span class="hljs-comment">//之后所有的对象都是直接偏向的状态，而不是先撤销t1偏锁，再升级轻锁 =&gt; 批量重偏向</span><br>[t2] - <span class="hljs-number">19</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01000000</span> <span class="hljs-number">00000101</span><br>[t2] - <span class="hljs-number">19</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01010001</span> <span class="hljs-number">00000101</span><br>[t2] - <span class="hljs-number">19</span><br><span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00011111</span> <span class="hljs-number">11101011</span> <span class="hljs-number">01010001</span> <span class="hljs-number">00000101</span><br>...<br></code></pre></td></tr></table></figure><h3 id="八、批量撤销"><a href="#八、批量撤销" class="headerlink" title="八、批量撤销"></a>八、批量撤销</h3><p>当撤销偏向锁阈值超过40次后，jvm 会这样觉得，自己确实偏向错了, 根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>    <span class="hljs-keyword">static</span> Thread t1, t2, t3;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        Vector&lt;Dog&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loopNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">39</span>;<br>        t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>                <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();<br>                list.add(d);<br>                <span class="hljs-comment">//39个对象加上偏向锁，偏向t1线程</span><br>                <span class="hljs-keyword">synchronized</span> (d) &#123;<br>                    log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>                &#125;<br>                <span class="hljs-comment">//39个对象加完锁唤醒t2(park，unpark方式)</span><br>                LockSupport.unpark(t2);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br>        t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<span class="hljs-comment">//先阻塞自己</span><br>            log.debug(<span class="hljs-string">&quot;============&gt; &quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>                <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> list.get(i);<span class="hljs-comment">//拿出list对象</span><br>                Log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>                <span class="hljs-comment">//对象加上偏向锁，偏向t2线程</span><br>                <span class="hljs-comment">//前19个对象是撤销t1偏向锁，之后对象是批量重偏向</span><br>                <span class="hljs-keyword">synchronized</span> (d) &#123;<br>                    Log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintablesimple(<span class="hljs-literal">true</span>));<br>                &#125;<br>                Log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>            &#125;<br>            <span class="hljs-comment">//此时已经重偏向了20次</span><br>            LockSupport.unpark(t3);<span class="hljs-comment">//唤醒t3</span><br><br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>        t2.start();<br>        t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<span class="hljs-comment">//先阻塞自己</span><br>            log.debug(<span class="hljs-string">&quot;============&gt; &quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>                <span class="hljs-type">Dog</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> list.get(i);<span class="hljs-comment">//拿出list对象</span><br>                Log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>                <span class="hljs-comment">//对象加上偏向锁，偏向t3线程</span><br>                <span class="hljs-comment">//前19个对象是撤销t2偏向锁，注意：之后对象也是撤销t2偏锁，没那么多机会重偏向锁了</span><br>                <span class="hljs-keyword">synchronized</span> (d) &#123;<br>                    Log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintablesimple(<span class="hljs-literal">true</span>));<br>                &#125;<br>                Log.debug(i + <span class="hljs-string">&quot;\t&quot;</span> + ClassLayout.parseInstance(d).toPrintableSimple(<span class="hljs-literal">true</span>));<br>            &#125;<br>            <span class="hljs-comment">//最后撤销偏向锁达到39次</span><br>        &#125;, <span class="hljs-string">&quot;t3&quot;</span>);<br>        t3.start();<br><br>        t3.join();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         当撤销偏向锁阈值超过40次后，jvm会这样觉得，自己确实偏向错了，根本就不该偏向。</span><br><span class="hljs-comment">         于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的，所以new Dog()是不可偏向的</span><br><span class="hljs-comment">        */</span><br>        Log.debug(ClassLayout.parseInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()).toPrintableSimple(<span class="hljs-literal">true</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="九、锁消除"><a href="#九、锁消除" class="headerlink" title="九、锁消除"></a>九、锁消除</h3><ul><li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li><li>在动态编译同步块的时候，JIT编译器可以<strong>借助逃逸分析</strong>来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</li><li>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫锁消除。</li></ul><p>例如下面的代码，<code>根本起不到锁的作用</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">synchronized</span>(hellis) &#123;<br>        System.out.println(hellis);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中对hellis这个对象加锁，但是hellis对象的生命周期只在f( )方法中，并不会被其他线程所访问到，所以在JIT编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">hellis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        System.out.println(hellis);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="十、锁粗化"><a href="#十、锁粗化" class="headerlink" title="十、锁粗化"></a>十、锁粗化</h4><p>锁粗化是一种优化方式，它能够解决线程重复加锁的问题。有些程序在处理同一个对象的时候，需要执行多个操作，如果每个操作都加锁，就会导致线程频繁地加锁和解锁。这样会影响程序的性能。锁粗化的处理方法是将多个锁粗略化为一个锁，这样就减少了加锁和解锁的次数，提高了程序的效率。需要注意的是，锁粗化和细分锁的粒度不同，它们解决的问题也不同。</p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>枚举类</title>
    <link href="/2023/03/27/%E6%9E%9A%E4%B8%BE%E7%B1%BB/"/>
    <url>/2023/03/27/%E6%9E%9A%E4%B8%BE%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>当需要一组常量时，强烈建议使用枚举类</p><p>若枚举只有一个对象, 则可以作为一种单例模式的实现方式</p><h2 id="自定义枚举类（JDK1-5之前）"><a href="#自定义枚举类（JDK1-5之前）" class="headerlink" title="自定义枚举类（JDK1.5之前）"></a><strong>自定义枚举类（JDK1.5之前）</strong></h2><ol><li>私有化类的构造器，保证不能在类的外部创建其对象</li><li>在类的内部创建枚举类的实例。声明为：public static final</li><li>对象如果有实例变量，应该声明为private final，并在构造器中初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自定义枚举类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Season</span>&#123;<br>    <span class="hljs-comment">//1.声明Season对象的属性:private final修饰</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonDesc;<br><br>    <span class="hljs-comment">//2.私化类的构造器,并给对象属性赋值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season</span><span class="hljs-params">(String seasonName,String seasonDesc)</span>&#123;<br>        <span class="hljs-built_in">this</span>.seasonName = seasonName;<br>        <span class="hljs-built_in">this</span>.seasonDesc = seasonDesc;<br>    &#125;<br><br>    <span class="hljs-comment">//3.提供当前枚举类的多个对象：public static final的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SPRING</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;春天&quot;</span>,<span class="hljs-string">&quot;春暖花开&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">SUMMER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;夏天&quot;</span>,<span class="hljs-string">&quot;夏日炎炎&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">AUTUMN</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;秋天&quot;</span>,<span class="hljs-string">&quot;秋高气爽&quot;</span>);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Season</span> <span class="hljs-variable">WINTER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Season</span>(<span class="hljs-string">&quot;冬天&quot;</span>,<span class="hljs-string">&quot;冰天雪地&quot;</span>);<br><br>    <span class="hljs-comment">//4.其他诉求1：获取枚举类对象的属性</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonDesc;<br>    &#125;<br>    <span class="hljs-comment">//4.其他诉求1：提供toString()</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Season&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="enum定义枚举类（JDK1-5之后）"><a href="#enum定义枚举类（JDK1-5之后）" class="headerlink" title="enum定义枚举类（JDK1.5之后）"></a><strong>enum定义枚举类（JDK1.5之后）</strong></h2><h3 id="●使用说明"><a href="#●使用说明" class="headerlink" title="●使用说明"></a>●使用说明</h3><ol><li>使用enum定义的枚举类默认继承了java.lang.Enum类，因此不能再继承其他类</li><li>枚举类的构造器只能使用private权限修饰符</li><li>枚举类的所有实例必须显式列出(，分隔；结尾)。列出的实例系统会自动添加public static final修饰</li><li>必须在枚举类的第一行声明枚举类对象</li><li>JDK1.5中可以在switch表达式中使用Enum定义的枚举类的对象作为表达式，case子句可以直接使用枚举值的名字，无需添加枚举类作为限定。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用enum关键字枚举类</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season1</span> &#123;<br>    <span class="hljs-comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span><br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>,<span class="hljs-string">&quot;春暖花开&quot;</span>),<br>    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>,<span class="hljs-string">&quot;夏日炎炎&quot;</span>),<br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>,<span class="hljs-string">&quot;秋高气爽&quot;</span>),<br>    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>,<span class="hljs-string">&quot;冰天雪地&quot;</span>);<br><br>    <span class="hljs-comment">//2.声明Season对象的属性:private final修饰</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonDesc;<br><br>    <span class="hljs-comment">//2.私化类的构造器,并给对象属性赋值</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season1</span><span class="hljs-params">(String seasonName,String seasonDesc)</span>&#123;<br>        <span class="hljs-built_in">this</span>.seasonName = seasonName;<br>        <span class="hljs-built_in">this</span>.seasonDesc = seasonDesc;<br>    &#125;<br><br>    <span class="hljs-comment">//4.其他诉求1：获取枚举类对象的属性</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonDesc;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Enum类的主要方法"><a href="#Enum类的主要方法" class="headerlink" title="Enum类的主要方法"></a><strong>Enum类的主要方法</strong></h2><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679894700912.png"></p><p>使用enum定义枚举类之后，枚举类常用方法：（继承于java.lang.Enum类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span>&#123;<br>    <span class="hljs-comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span><br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>,<span class="hljs-string">&quot;春暖花开&quot;</span>),<br>    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>,<span class="hljs-string">&quot;夏日炎炎&quot;</span>),<br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>,<span class="hljs-string">&quot;秋高气爽&quot;</span>),<br>    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>,<span class="hljs-string">&quot;冰天雪地&quot;</span>);<br><br>    <span class="hljs-comment">//2.声明Season对象的属性:private final修饰</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String seasonDesc;<br><br>    <span class="hljs-comment">//2.私化类的构造器,并给对象属性赋值</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Season</span><span class="hljs-params">(String seasonName,String seasonDesc)</span>&#123;<br>        <span class="hljs-built_in">this</span>.seasonName = seasonName;<br>        <span class="hljs-built_in">this</span>.seasonDesc = seasonDesc;<br>    &#125;<br><br>    <span class="hljs-comment">//4.其他诉求1：获取枚举类对象的属性</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonName;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getSeasonDesc</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> seasonDesc;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Season</span> <span class="hljs-variable">summer</span> <span class="hljs-operator">=</span> Season.SUMMER;<br>        <span class="hljs-comment">//toString():返回枚举类对象的名称</span><br>        System.out.println(summer.toString());<br><br><span class="hljs-comment">//        System.out.println(Season1.class.getSuperclass());</span><br>        System.out.println(<span class="hljs-string">&quot;****************&quot;</span>);<br>        <span class="hljs-comment">//values():返回所的枚举类对象构成的数组</span><br>        Season[] values = Season.values();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;i &lt; values.length;i++)&#123;<br>            System.out.println(values[i]);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;****************&quot;</span>);<br>        <span class="hljs-comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span><br>        <span class="hljs-type">Season</span> <span class="hljs-variable">winter</span> <span class="hljs-operator">=</span> Season.valueOf(<span class="hljs-string">&quot;WINTER&quot;</span>);<br>        <span class="hljs-comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span><br><span class="hljs-comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span><br>        System.out.println(winter);<br><br><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">SUMMER<br>****************<br>SPRING<br>SUMMER<br>AUTUMN<br>WINTER<br>****************<br>WINTER<br></code></pre></td></tr></table></figure><h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><p>使用enum定义枚举类之后，如何让枚举类对象分别实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Info</span>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">//使用enum关键字枚举类</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Season</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Info</span>&#123;<br>    <span class="hljs-comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span><br>    SPRING(<span class="hljs-string">&quot;春天&quot;</span>,<span class="hljs-string">&quot;春暖花开&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;春天在哪里？&quot;</span>);<br>        &#125;<br>    &#125;,<br>    SUMMER(<span class="hljs-string">&quot;夏天&quot;</span>,<span class="hljs-string">&quot;夏日炎炎&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;宁夏&quot;</span>);<br>        &#125;<br>    &#125;,<br>    AUTUMN(<span class="hljs-string">&quot;秋天&quot;</span>,<span class="hljs-string">&quot;秋高气爽&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;秋天不回来&quot;</span>);<br>        &#125;<br>    &#125;,<br>    WINTER(<span class="hljs-string">&quot;冬天&quot;</span>,<span class="hljs-string">&quot;冰天雪地&quot;</span>)&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;大约在冬季&quot;</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringAOP原理解析</title>
    <link href="/2023/03/26/SpringAOP%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/03/26/SpringAOP%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>AOP 底层实现方式之一是代理，由代理结合通知和目标，提供增强功能</p><p>除此以外，aspectj 提供了两种另外的 AOP 底层实现：</p><ul><li>第一种是通过 ajc 编译器在<strong>编译</strong> class 类文件时，就把通知的增强功能，织入到目标类的字节码中 </li><li>第二种是通过 agent 在<strong>加载</strong>目标类时，修改目标类的字节码，织入增强功能 </li><li>作为对比，之前学习的代理是<strong>运行</strong>时生成新的字节码</li></ul><p>简单比较的话：</p><ul><li>aspectj 在编译和加载时，修改目标字节码，性能较高</li><li>aspectj 因为不用代理，能突破一些技术上的限制，例如对构造、对静态方法、对 final 也能增强</li><li>但 aspectj 侵入性较强，且需要学习新的 aspectj 特有语法，因此没有广泛流行</li></ul><h2 id="ajc-编译器"><a href="#ajc-编译器" class="headerlink" title="ajc 编译器"></a>ajc 编译器</h2><ol><li>编译器也能修改 class 实现增强</li><li>编译器增强能突破代理仅能通过方法重写增强的限制：可以对构造方法、静态方法等实现增强</li></ol><p><em><strong>注意</strong></em></p><ul><li>版本选择了 java 8, 因为目前的 aspectj-maven-plugin 1.14.0 最高只支持到 java 16</li><li>一定要用 maven 的 compile 来编译, idea 不会调用 ajc 编译器</li></ul><h2 id="agent-类加载"><a href="#agent-类加载" class="headerlink" title="agent 类加载"></a>agent 类加载</h2><ol><li>类加载时可以通过 agent 修改 class 实现增强</li></ol><h2 id="AOP-实现之-proxy"><a href="#AOP-实现之-proxy" class="headerlink" title="AOP 实现之 proxy"></a>AOP 实现之 proxy</h2><h3 id="jdk-动态代理"><a href="#jdk-动态代理" class="headerlink" title="jdk 动态代理"></a>jdk 动态代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkProxyDemo</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Foo</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target foo&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// jdk 只能针对接口代理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] param)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 目标对象</span><br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br><br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> JdkProxyDemo.class.getClassLoader(); <span class="hljs-comment">// 用来加载在运行期间动态生成的字节码</span><br>        <span class="hljs-type">Foo</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Foo) Proxy.newProxyInstance(loader, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;Foo.class&#125;, (p, method, args) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>            <span class="hljs-comment">// 目标.方法(参数)</span><br>            <span class="hljs-comment">// 方法.invoke(目标, 参数);</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>            System.out.println(<span class="hljs-string">&quot;after....&quot;</span>);<br>            <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 让代理也返回目标方法执行的结果</span><br>        &#125;);<br><br>        System.out.println(proxy.getClass());<br><br>        proxy.foo();<br><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">proxy before...<br>target foo<br>proxy after...<br></code></pre></td></tr></table></figure><p>注意：jdk 动态代理要求目标<strong>必须</strong>实现接口，生成的代理类实现相同接口，因此代理与目标之间是平级兄弟关系</p><h4 id="模拟-jdk-动态代理"><a href="#模拟-jdk-动态代理" class="headerlink" title="模拟 jdk 动态代理"></a>模拟 jdk 动态代理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A12</span> &#123;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Foo</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target foo&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target bar&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] param)</span> &#123;<br>        <span class="hljs-comment">// ⬇️1. 创建代理，这时传入 InvocationHandler</span><br>        <span class="hljs-type">Foo</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">$Proxy0</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InvocationHandler</span>() &#123;    <br>            <span class="hljs-comment">// ⬇️5. 进入 InvocationHandler</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable&#123;<br>                <span class="hljs-comment">// ⬇️6. 功能增强</span><br>                System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>                <span class="hljs-comment">// ⬇️7. 反射调用目标方法</span><br>                <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>(), args);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// ⬇️2. 调用代理方法</span><br>        proxy.foo();<br>        proxy.bar();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>模拟代理实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.UndeclaredThrowableException;<br><br><span class="hljs-comment">// ⬇️这就是 jdk 代理类的源码, 秘密都在里面</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">$Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A12</span>.Foo &#123;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler h) &#123;<br>        <span class="hljs-built_in">super</span>(h);<br>    &#125;<br>    <span class="hljs-comment">// ⬇️3. 进入代理方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ⬇️4. 回调 InvocationHandler</span><br>            h.invoke(<span class="hljs-built_in">this</span>, foo, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]);<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> h.invoke(<span class="hljs-built_in">this</span>, bar, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) result;<br>        &#125; <span class="hljs-keyword">catch</span> (RuntimeException | Error e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UndeclaredThrowableException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Method foo;<br>    <span class="hljs-keyword">static</span> Method bar;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            foo = A12.Foo.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>);<br>            bar = A12.Foo.class.getMethod(<span class="hljs-string">&quot;bar&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchMethodError</span>(e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代理一点都不难，无非就是利用了多态、反射的知识</p><ol><li>方法重写可以增强逻辑，只不过这【增强逻辑】千变万化，不能写死在代理内部</li><li>通过接口回调将【增强逻辑】置于代理类之外</li><li>配合接口方法反射（是多态调用），就可以再联动调用目标方法</li><li>会用 arthas 的 jad 工具反编译代理类</li></ol><h4 id="限制⛔："><a href="#限制⛔：" class="headerlink" title="限制⛔："></a>限制⛔：</h4><p>由于JDK动态代理是基于接口实现的，所以它只能代理接口中的方法，而不能代理类中的成员变量、静态方法以及final方法。</p><p>成员变量是对象的属性，与方法不同，成员变量并不是接口中定义的一部分，所以不能通过代理实现。静态方法属于类而不是对象，因此即使代理了对象，也无法代理类的静态方法。final方法在编译期就已经绑定到方法调用点，因此不能被代理。</p><p>需要注意的是，虽然JDK动态代理不能代理类中的成员变量、静态方法以及final方法，但是它可以代理接口中的默认方法，因为默认方法是接口中的一种特殊方法，可以在接口中定义和实现。</p><p>如果需要代理类中的成员变量、静态方法以及final方法，可以考虑使用其他类型的代理，例如CGLIB代理或者字节码操作库ASM。</p><h4 id="方法反射优化"><a href="#方法反射优化" class="headerlink" title="方法反射优化"></a>方法反射优化</h4><ol><li>前 16 次反射性能较低</li><li>第 17 次调用会生成代理类，优化为非反射调用</li></ol><h3 id="cglib-代理"><a href="#cglib-代理" class="headerlink" title="cglib 代理"></a>cglib 代理</h3><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibProxyDemo</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target foo&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 代理是子类型, 目标是父类型</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] param)</span> &#123;<br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br><br>        <span class="hljs-type">Target</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Target) Enhancer.create(Target.class, (MethodInterceptor) (p, method, args, methodProxy) -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br><span class="hljs-comment">//            Object result = method.invoke(target, args); // 用方法反射调用目标</span><br>            <span class="hljs-comment">// methodProxy 它可以避免反射调用</span><br><span class="hljs-comment">//            Object result = methodProxy.invoke(target, args); // 内部没有用反射, 需要目标 （spring）</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> methodProxy.invokeSuper(p, args); <span class="hljs-comment">// 内部没有用反射, 需要代理</span><br>            System.out.println(<span class="hljs-string">&quot;after...&quot;</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;);<br><br>        proxy.foo();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：调用目标时有所改进，见下面代码片段</p><ol><li><ol><li>method.invoke 是反射调用，必须调用到足够次数才会进行优化</li><li>methodProxy.invoke 是不反射调用，它会正常（间接）调用目标对象的方法（Spring 采用）</li><li>methodProxy.invokeSuper 也是不反射调用，它会正常（间接）调用代理对象的方法，可以省略目标对象</li></ol></li></ol><ul><li>cglib 不要求目标实现接口，它生成的代理类是目标的子类，因此代理与目标之间是子父关系</li><li>限制⛔：根据上述分析 final 类无法被 cglib 增强</li></ul><h3 id="jdk-和-cglib-在-Spring-中的统一"><a href="#jdk-和-cglib-在-Spring-中的统一" class="headerlink" title="jdk 和 cglib 在 Spring 中的统一"></a>jdk 和 cglib 在 Spring 中的统一</h3><p>Spring 中对切点、通知、切面的抽象如下</p><ul><li>切点：接口 Pointcut，典型实现 AspectJExpressionPointcut</li><li>通知：典型接口为 MethodInterceptor 代表环绕通知</li><li>切面：Advisor，包含一个 Advice 通知，PointcutAdvisor 包含一个 Advice 通知和一个 Pointcut</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679831677049.png"></p><p>相关术语</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679831736062.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">两个切面概念<br>aspect =<br>    通知1(advice) +  切点1(pointcut)<br>    通知2(advice) +  切点2(pointcut)<br>    通知3(advice) +  切点3(pointcut)<br>    ...<br>advisor = 更细粒度的切面，包含一个通知和切点<br></code></pre></td></tr></table></figure><p>代理相关类图</p><ul><li>AopProxyFactory 根据 proxyTargetClass 等设置选择 AopProxy 实现</li><li>AopProxy 通过 getProxy 创建代理对象</li><li>图中 Proxy 都实现了 Advised 接口，能够获得关联的切面集合与目标（其实是从 ProxyFactory 取得）</li><li>调用代理方法时，会借助 ProxyFactory 将通知统一转为环绕通知：MethodInterceptor</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679831772189.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">// 1. 备好切点</span><br>        <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJExpressionPointcut</span>();<br>        pointcut.setExpression(<span class="hljs-string">&quot;execution(* foo())&quot;</span>);<br>        <span class="hljs-comment">// 2. 备好通知</span><br>        <span class="hljs-type">MethodInterceptor</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> invocation -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed(); <span class="hljs-comment">// 调用目标</span><br>            System.out.println(<span class="hljs-string">&quot;after...&quot;</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;;<br>        <span class="hljs-comment">// 3. 备好切面</span><br>        <span class="hljs-type">DefaultPointcutAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           4. 创建代理</span><br><span class="hljs-comment">                a. proxyTargetClass = false, 目标实现了接口, 用 jdk 实现</span><br><span class="hljs-comment">                b. proxyTargetClass = false,  目标没有实现接口, 用 cglib 实现</span><br><span class="hljs-comment">                c. proxyTargetClass = true, 总是使用 cglib 实现</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Target2</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target2</span>();<br>        <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>        factory.setTarget(target);<br>        factory.addAdvisor(advisor);<br>        factory.setInterfaces(target.getClass().getInterfaces());<br>        factory.setProxyTargetClass(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Target2</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (Target2) factory.getProxy();<br>        System.out.println(proxy.getClass());<br>        proxy.foo();<br>        proxy.bar();<br>        <br>    &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">I1</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">I1</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target1 foo&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target1 bar&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target2</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target2 foo&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target2 bar&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>收获：</p><ol><li>底层的切点实现</li><li>底层的通知实现</li><li>底层的切面实现</li><li>ProxyFactory 用来创建代理</li></ol><ul><li><ul><li>如果指定了接口，且 proxyTargetClass &#x3D; false，使用 JdkDynamicAopProxy</li><li>如果没有指定接口，或者 proxyTargetClass &#x3D; true，使用 ObjenesisCglibAopProxy</li></ul></li><li><ul><li><ul><li>例外：如果目标是接口类型或已经是 Jdk 代理，使用 JdkDynamicAopProxy</li></ul></li></ul></li></ul><p><em><strong>注意</strong></em></p><ul><li>要区分本章节提到的 MethodInterceptor，它与之前 cglib 中用的的 MethodInterceptor 是不同的接口</li></ul><h2 id="切点匹配"><a href="#切点匹配" class="headerlink" title="切点匹配"></a>切点匹配</h2><h3 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h3><p>a. 底层切点实现是如何匹配的: 调用了 aspectj 的匹配方法</p><p>b. 比较关键的是它实现了 MethodMatcher 接口, 用来执行方法的匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException &#123;<br><span class="hljs-comment">//        AspectJExpressionPointcut pt1 = new AspectJExpressionPointcut();</span><br><span class="hljs-comment">//        pt1.setExpression(&quot;execution(* bar())&quot;);</span><br><span class="hljs-comment">//        System.out.println(pt1.matches(T1.class.getMethod(&quot;foo&quot;), T1.class));</span><br><span class="hljs-comment">//        System.out.println(pt1.matches(T1.class.getMethod(&quot;bar&quot;), T1.class));</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        AspectJExpressionPointcut pt2 = new AspectJExpressionPointcut();</span><br><span class="hljs-comment">//        pt2.setExpression(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;);</span><br><span class="hljs-comment">//        System.out.println(pt2.matches(T1.class.getMethod(&quot;foo&quot;), T1.class));</span><br><span class="hljs-comment">//        System.out.println(pt2.matches(T1.class.getMethod(&quot;bar&quot;), T1.class));</span><br><br>        <span class="hljs-type">StaticMethodMatcherPointcut</span> <span class="hljs-variable">pt3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StaticMethodMatcherPointcut</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span> &#123;<br>                <span class="hljs-comment">// 检查方法上是否加了 Transactional 注解</span><br>                <span class="hljs-type">MergedAnnotations</span> <span class="hljs-variable">annotations</span> <span class="hljs-operator">=</span> MergedAnnotations.from(method);<br>                <span class="hljs-keyword">if</span> (annotations.isPresent(Transactional.class)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 查看类上是否加了 Transactional 注解</span><br>                annotations = MergedAnnotations.from(targetClass, MergedAnnotations.SearchStrategy.TYPE_HIERARCHY);<br>                <span class="hljs-keyword">if</span> (annotations.isPresent(Transactional.class)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;;<br><br>        System.out.println(pt3.matches(T1.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>), T1.class));<br>        System.out.println(pt3.matches(T1.class.getMethod(<span class="hljs-string">&quot;bar&quot;</span>), T1.class));<br>        System.out.println(pt3.matches(T2.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>), T2.class));<br>        System.out.println(pt3.matches(T3.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>), T3.class));<br><br><br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T1</span> &#123;<br>        <span class="hljs-meta">@Transactional</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T2</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">I3</span> &#123;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span>;<br>    &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">T3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">I3</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="从-Aspect-到-Advisor"><a href="#从-Aspect-到-Advisor" class="headerlink" title="从 @Aspect 到 Advisor"></a>从 @Aspect 到 Advisor</h2><p>a. 自动代理后处理器 AnnotationAwareAspectJAutoProxyCreator 会帮我们创建代理</p><p>bean对象的生命周期： 创建 -&gt; (<em>) 依赖注入 -&gt; 初始化 (</em>) ，打星号处可以进行代理的增强</p><p>b. 通常代理创建的活在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</p><p>c. 高级的 @Aspect 切面会转换为低级的 Advisor 切面</p><h3 id="关键方法"><a href="#关键方法" class="headerlink" title="关键方法"></a>关键方法</h3><ol><li>findEligibleAdvisors 找到有【资格】的 Advisors</li></ol><ul><li><ul><li>有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如本例 A17 中的 advisor3</li><li>有【资格】的 Advisor 另一部分是高级的, 由解析 @Aspect  后获得</li></ul></li></ul><ol><li>wrapIfNecessary</li></ol><ul><li><ul><li>它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理</li><li>它的调用时机通常在原始对象初始化后执行, 但碰到循环依赖会提前至依赖注入之前执行</li></ul></li></ul><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GenericApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericApplicationContext</span>();<br>        context.registerBean(<span class="hljs-string">&quot;aspect1&quot;</span>, Aspect1.class);<br>        context.registerBean(<span class="hljs-string">&quot;config&quot;</span>, Config.class);<br>        context.registerBean(ConfigurationClassPostProcessor.class);<br>        context.registerBean(AnnotationAwareAspectJAutoProxyCreator.class);<br>        <span class="hljs-comment">// BeanPostProcessor</span><br>        <span class="hljs-comment">// 创建 -&gt; (*) 依赖注入 -&gt; 初始化 (*)</span><br><br>        context.refresh();<br><span class="hljs-comment">//        for (String name : context.getBeanDefinitionNames()) &#123;</span><br><span class="hljs-comment">//            System.out.println(name);</span><br><span class="hljs-comment">//        &#125;</span><br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            第一个重要方法 findEligibleAdvisors 找到有【资格】的 Advisors</span><br><span class="hljs-comment">                a. 有【资格】的 Advisor 一部分是低级的, 可以由自己编写, 如下例中的 advisor3</span><br><span class="hljs-comment">                b. 有【资格】的 Advisor 另一部分是高级的, 由本章的主角解析 @Aspect 后获得</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">AnnotationAwareAspectJAutoProxyCreator</span> <span class="hljs-variable">creator</span> <span class="hljs-operator">=</span> context.getBean(AnnotationAwareAspectJAutoProxyCreator.class);<br>        List&lt;Advisor&gt; advisors = creator.findEligibleAdvisors(Target2.class, <span class="hljs-string">&quot;target2&quot;</span>);<br>        <span class="hljs-comment">/*for (Advisor advisor : advisors) &#123;</span><br><span class="hljs-comment">            System.out.println(advisor);</span><br><span class="hljs-comment">        &#125;*/</span><br><br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            第二个重要方法 wrapIfNecessary</span><br><span class="hljs-comment">                a. 它内部调用 findEligibleAdvisors, 只要返回集合不空, 则表示需要创建代理</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> creator.wrapIfNecessary(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Target1</span>(), <span class="hljs-string">&quot;target1&quot;</span>, <span class="hljs-string">&quot;target1&quot;</span>);<br>        System.out.println(o1.getClass());<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> creator.wrapIfNecessary(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Target2</span>(), <span class="hljs-string">&quot;target2&quot;</span>, <span class="hljs-string">&quot;target2&quot;</span>);<br>        System.out.println(o2.getClass());<br><br>        ((Target1) o1).foo();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target1</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target1 foo&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target2</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target2 bar&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 高级切面类</span><br>    <span class="hljs-meta">@Order(1)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Aspect1</span> &#123;<br>        <span class="hljs-meta">@Before(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before1</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;aspect1 before1...&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Before(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before2</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;aspect1 before2...&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Configuration</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>        <span class="hljs-meta">@Bean</span> <span class="hljs-comment">// 低级切面</span><br>        <span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">advisor3</span><span class="hljs-params">(MethodInterceptor advice3)</span> &#123;<br>            <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJExpressionPointcut</span>();<br>            pointcut.setExpression(<span class="hljs-string">&quot;execution(* foo())&quot;</span>);<br>            <span class="hljs-type">DefaultPointcutAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice3);<br>            <span class="hljs-keyword">return</span> advisor;<br>        &#125;<br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> MethodInterceptor <span class="hljs-title function_">advice3</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> invocation -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;advice3 before...&quot;</span>);<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();<br>                System.out.println(<span class="hljs-string">&quot;advice3 after...&quot;</span>);<br>                <span class="hljs-keyword">return</span> result;<br>            &#125;;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代理创建时机"><a href="#代理创建时机" class="headerlink" title="代理创建时机"></a>代理创建时机</h3><p>a. 代理的创建时机</p><p>​    1. 初始化之后 (无循环依赖时)</p><p>​    2. 实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存</p><p>b. 依赖注入与初始化不应该被增强, 仍应被施加于原始对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GenericApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericApplicationContext</span>();<br>        context.registerBean(ConfigurationClassPostProcessor.class);<br>        context.registerBean(Config.class);<br>        context.refresh();<br>        context.close();<br>        <span class="hljs-comment">// 创建 -&gt; (*) 依赖注入 -&gt; 初始化 (*)</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            学到了什么</span><br><span class="hljs-comment">                a. 代理的创建时机</span><br><span class="hljs-comment">                    1. 初始化之后 (无循环依赖时)</span><br><span class="hljs-comment">                    2. 实例创建后, 依赖注入前 (有循环依赖时), 并暂存于二级缓存</span><br><span class="hljs-comment">                b. 依赖注入与初始化不应该被增强, 仍应被施加于原始对象</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>    <span class="hljs-meta">@Configuration</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>        <span class="hljs-meta">@Bean</span> <span class="hljs-comment">// 解析 @Aspect、产生代理</span><br>        <span class="hljs-keyword">public</span> AnnotationAwareAspectJAutoProxyCreator <span class="hljs-title function_">annotationAwareAspectJAutoProxyCreator</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationAwareAspectJAutoProxyCreator</span>();<br>        &#125;<br><br>        <span class="hljs-meta">@Bean</span> <span class="hljs-comment">// 解析 @Autowired</span><br>        <span class="hljs-keyword">public</span> AutowiredAnnotationBeanPostProcessor <span class="hljs-title function_">autowiredAnnotationBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutowiredAnnotationBeanPostProcessor</span>();<br>        &#125;<br><br>        <span class="hljs-meta">@Bean</span> <span class="hljs-comment">// 解析 @PostConstruct</span><br>        <span class="hljs-keyword">public</span> CommonAnnotationBeanPostProcessor <span class="hljs-title function_">commonAnnotationBeanPostProcessor</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonAnnotationBeanPostProcessor</span>();<br>        &#125;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> Advisor <span class="hljs-title function_">advisor</span><span class="hljs-params">(MethodInterceptor advice)</span> &#123;<br>            <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJExpressionPointcut</span>();<br>            pointcut.setExpression(<span class="hljs-string">&quot;execution(* foo())&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice);<br>        &#125;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> MethodInterceptor <span class="hljs-title function_">advice</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> (MethodInvocation invocation) -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>                <span class="hljs-keyword">return</span> invocation.proceed();<br>            &#125;;<br>        &#125;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> Bean1 <span class="hljs-title function_">bean1</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bean1</span>();<br>        &#125;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> Bean2 <span class="hljs-title function_">bean2</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bean2</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bean1</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bean1</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Bean1()&quot;</span>);<br>        &#125;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBean2</span><span class="hljs-params">(Bean2 bean2)</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Bean1 setBean2(bean2) class is: &quot;</span> + bean2.getClass());<br>        &#125;<br>        <span class="hljs-meta">@PostConstruct</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Bean1 init()&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bean2</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bean2</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Bean2()&quot;</span>);<br>        &#125;<br>        <span class="hljs-meta">@Autowired</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBean1</span><span class="hljs-params">(Bean1 bean1)</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Bean2 setBean1(bean1) class is: &quot;</span> + bean1.getClass());<br>        &#125;<br>        <span class="hljs-meta">@PostConstruct</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Bean2 init()&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">[INFO ] <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">46.282</span> [main] o.s.c.s.PostProcessorRegistrationDelegate$BeanPostProcessorChecker - Bean <span class="hljs-string">&#x27;org.springframework.aop.framework.autoproxy.A17_1$Config&#x27;</span> of type [org.springframework.aop.framework.autoproxy.A17_1$Config$$EnhancerBySpringCGLIB$$ebf9effa] is not eligible <span class="hljs-keyword">for</span> getting processed by all <span class="hljs-title function_">BeanPostProcessors</span> <span class="hljs-params">(<span class="hljs-keyword">for</span> example: not eligible <span class="hljs-keyword">for</span> auto-proxying)</span> <br>[TRACE] <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">46.326</span> [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Did not attempt to auto-proxy infrastructure class [org.springframework.aop.Advisor] <br>[TRACE] <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">46.328</span> [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Did not attempt to auto-proxy infrastructure class [org.aopalliance.intercept.MethodInterceptor] <br>Bean1()<br>Bean2()<br>[TRACE] <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">46.460</span> [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy <span class="hljs-keyword">for</span> bean <span class="hljs-string">&#x27;bean1&#x27;</span> with <span class="hljs-number">0</span> common interceptors and <span class="hljs-number">2</span> specific interceptors <br>Bean2 <span class="hljs-title function_">setBean1</span><span class="hljs-params">(bean1)</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">is</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean1$$EnhancerBySpringCGLIB$$5455d566<br>Bean2 <span class="hljs-title function_">init</span><span class="hljs-params">()</span><br>[TRACE] <span class="hljs-number">14</span>:<span class="hljs-number">01</span>:<span class="hljs-number">46.471</span> [main] o.s.a.a.a.AnnotationAwareAspectJAutoProxyCreator - Creating implicit proxy <span class="hljs-keyword">for</span> bean <span class="hljs-string">&#x27;bean2&#x27;</span> with <span class="hljs-number">0</span> common interceptors and <span class="hljs-number">2</span> specific interceptors <br>Bean1 <span class="hljs-title function_">setBean2</span><span class="hljs-params">(bean2)</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">is</span>: <span class="hljs-keyword">class</span> <span class="hljs-title class_">org</span>.springframework.aop.framework.autoproxy.A17_1$Bean2$$EnhancerBySpringCGLIB$$67f15e09<br>Bean1 <span class="hljs-title function_">init</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><h3 id="高级切面转成低级切面"><a href="#高级切面转成低级切面" class="headerlink" title="@高级切面转成低级切面"></a>@高级切面转成低级切面</h3><p>演示findEligibleAdvisors和wrapIfNecessary方法底层具体怎么将高级切面转换成低级切面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Aspect</span> &#123;<br>        <span class="hljs-meta">@Before(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before1</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;before1&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Before(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before2</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;before2&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;after&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;afterReturning&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;afterThrowing&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;around...before&quot;</span>);<br>                <span class="hljs-keyword">return</span> pjp.proceed();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;around...after&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target foo&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        <span class="hljs-type">AspectInstanceFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonAspectInstanceFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Aspect</span>());<br>        <span class="hljs-comment">// 高级切面转低级切面类</span><br>        List&lt;Advisor&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;<br>            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;<br>                <span class="hljs-comment">// 解析切点</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> method.getAnnotation(Before.class).value();<br>                <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJExpressionPointcut</span>();<br>                pointcut.setExpression(expression);<br>                <span class="hljs-comment">// 通知类</span><br>                <span class="hljs-type">AspectJMethodBeforeAdvice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);<br>                <span class="hljs-comment">// 切面</span><br>                <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice);<br>                list.add(advisor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Advisor advisor : list) &#123;<br>            System.out.println(advisor);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            @Before 前置通知会被转换为下面原始的 AspectJMethodBeforeAdvice 形式, 该对象包含了如下信息</span><br><span class="hljs-comment">                a. 通知代码从哪儿来</span><br><span class="hljs-comment">                b. 切点是什么(这里为啥要切点, 后面解释)</span><br><span class="hljs-comment">                c. 通知对象如何创建, 本例共用同一个 Aspect 对象</span><br><span class="hljs-comment">            类似的通知还有</span><br><span class="hljs-comment">                1. AspectJAroundAdvice (环绕通知)</span><br><span class="hljs-comment">                2. AspectJAfterReturningAdvice</span><br><span class="hljs-comment">                3. AspectJAfterThrowingAdvice</span><br><span class="hljs-comment">                4. AspectJAfterAdvice (环绕通知)</span><br><span class="hljs-comment">         */</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li><p>@Before  前置通知会被转换为原始的 AspectJMethodBeforeAdvice 形式, 该对象包含了如下信息  </p></li><li><ol><li>通知代码从哪儿来</li><li>切点是什么(这里为啥要切点, 后面解释)</li><li>通知对象如何创建, 本例共用同一个 Aspect 对象</li></ol></li><li><p>类似的还有 </p></li><li><ol><li>AspectJAroundAdvice (环绕通知)</li><li>AspectJAfterReturningAdvice</li><li>AspectJAfterThrowingAdvice (环绕通知)</li><li>AspectJAfterAdvice (环绕通知)</li></ol></li><li><p>通知统一转换为环绕通知 MethodInterceptor</p></li><li><p>其实无论 ProxyFactory 基于哪种方式创建代理, 最后干活(调用 advice)的是一个 MethodInvocation 对象<br>a. 因为 advisor 有多个, 且一个套一个调用, 因此需要一个调用链对象, 即 MethodInvocation<br>b. MethodInvocation 要知道 advice（通知） 有哪些, 还要知道目标, 调用次序如下</p></li></ol><p> 将 MethodInvocation 放入当前线程</p><p>​     |-&gt; before1 ———————————– 从当前线程获取 MethodInvocation</p><p>​     |                                             |</p><p>​     |   |-&gt; before2 ——————–          | 从当前线程获取 MethodInvocation</p><p>​     |   |                              |          |</p><p>​     |   |   |-&gt; target —— 目标   advice2    advice1</p><p>​     |   |                              |          |</p><p>​     |   |-&gt; after2 ———————          |</p><p>​     |                                             |</p><p>​     |-&gt; after1 ————————————</p><p> c. 从上图看出, 环绕通知才适合作为 advice, 因此其他 before、afterReturning 都会被转换成环绕通知</p><p> d. 统一转换为环绕通知, 体现的是设计模式中的适配器模式</p><p>​     - 对外是为了方便使用要区分 before、afterReturning</p><p>​     - 对内统一都是环绕通知, 统一用 MethodInterceptor 表示</p><p>1.<br>   此步获取所有执行时需要的 advice (静态)<br>   a. 即统一转换为 MethodInterceptor 环绕通知, 这体现在方法名中的 Interceptors 上<br>   b. 适配如下:    (这里使用了适配器模式）<br>   - MethodBeforeAdviceAdapter 将 @Before  AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor<br>   - AfterReturningAdviceAdapter 将 @AfterReturning  AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Aspect</span> &#123;<br>        <span class="hljs-meta">@Before(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before1</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;before1&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Before(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before2</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;before2&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;after&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@AfterReturning(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterReturning</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;afterReturning&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@AfterThrowing(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterThrowing</span><span class="hljs-params">(Exception e)</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;afterThrowing &quot;</span> + e.getMessage());<br>        &#125;<br><br>        <span class="hljs-meta">@Around(&quot;execution(* foo())&quot;)</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;around...before&quot;</span>);<br>                <span class="hljs-keyword">return</span> pjp.proceed();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;around...after&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;target foo&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;all&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        <span class="hljs-type">AspectInstanceFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonAspectInstanceFactory</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Aspect</span>());<br>        <span class="hljs-comment">// 1. 高级切面转低级切面类</span><br>        List&lt;Advisor&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Method method : Aspect.class.getDeclaredMethods()) &#123;<br>            <span class="hljs-keyword">if</span> (method.isAnnotationPresent(Before.class)) &#123;<br>                <span class="hljs-comment">// 解析切点</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> method.getAnnotation(Before.class).value();<br>                <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJExpressionPointcut</span>();<br>                pointcut.setExpression(expression);<br>                <span class="hljs-comment">// 通知类</span><br>                <span class="hljs-type">AspectJMethodBeforeAdvice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJMethodBeforeAdvice</span>(method, pointcut, factory);<br>                <span class="hljs-comment">// 切面</span><br>                <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice);<br>                list.add(advisor);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.isAnnotationPresent(AfterReturning.class)) &#123;<br>                <span class="hljs-comment">// 解析切点</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> method.getAnnotation(AfterReturning.class).value();<br>                <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJExpressionPointcut</span>();<br>                pointcut.setExpression(expression);<br>                <span class="hljs-comment">// 通知类</span><br>                <span class="hljs-type">AspectJAfterReturningAdvice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAfterReturningAdvice</span>(method, pointcut, factory);<br>                <span class="hljs-comment">// 切面</span><br>                <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice);<br>                list.add(advisor);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (method.isAnnotationPresent(Around.class)) &#123;<br>                <span class="hljs-comment">// 解析切点</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">expression</span> <span class="hljs-operator">=</span> method.getAnnotation(Around.class).value();<br>                <span class="hljs-type">AspectJExpressionPointcut</span> <span class="hljs-variable">pointcut</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJExpressionPointcut</span>();<br>                pointcut.setExpression(expression);<br>                <span class="hljs-comment">// 通知类</span><br>                <span class="hljs-type">AspectJAroundAdvice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AspectJAroundAdvice</span>(method, pointcut, factory);<br>                <span class="hljs-comment">// 切面</span><br>                <span class="hljs-type">Advisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPointcutAdvisor</span>(pointcut, advice);<br>                list.add(advisor);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Advisor advisor : list) &#123;<br>            System.out.println(advisor);<br>        &#125;<br><br>       <span class="hljs-comment">//2. 通知统一转换为环绕通知 MethodInterceptor</span><br>        <br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br>        <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">proxyFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>        proxyFactory.setTarget(target);<br>        proxyFactory.addAdvice(ExposeInvocationInterceptor.INSTANCE); <span class="hljs-comment">// 准备把 MethodInvocation 放入当前线程</span><br>        proxyFactory.addAdvisors(list);<br><br>        System.out.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);<br>        <span class="hljs-comment">//将各个通知转换成环绕通知</span><br>        List&lt;Object&gt; methodInterceptorList = proxyFactory.getInterceptorsAndDynamicInterceptionAdvice(Target.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>), Target.class);<br>        <span class="hljs-keyword">for</span> (Object o : methodInterceptorList) &#123;<br>            System.out.println(o);<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);<br>        <span class="hljs-comment">// 3. 创建并执行调用链 (环绕通知s + 目标)</span><br>        <span class="hljs-type">MethodInvocation</span> <span class="hljs-variable">methodInvocation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveMethodInvocation</span>(<br>                <span class="hljs-literal">null</span>, target, Target.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>], Target.class, methodInterceptorList<br>        );<br>        methodInvocation.proceed();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态通知调用"><a href="#静态通知调用" class="headerlink" title="静态通知调用"></a>静态通知调用</h3><p>代理对象调用流程如下（以 JDK 动态代理实现为例）</p><ul><li>从 ProxyFactory 获得 Target 和环绕通知链，根据他俩创建 MethodInvocation，简称 mi</li><li>首次执行 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知1，执行前增强，再次调用 mi.proceed() 发现有下一个环绕通知，调用它的 invoke(mi)</li><li>进入环绕通知2，执行前增强，调用 mi.proceed() 发现没有环绕通知，调用 mi.invokeJoinPoint() 执行目标方法</li><li>目标方法执行结束，将结果返回给环绕通知2，执行环绕通知2 的后增强</li><li>环绕通知2继续将结果返回给环绕通知1，执行环绕通知1 的后增强</li><li>环绕通知1返回最终的结果</li></ul><p>图中不同颜色对应一次环绕通知或目标的调用起始至终结</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679831825086.png"></p><p>代理方法执行时会做如下工作</p><ol><li>通过 proxyFactory 的 getInterceptorsAndDynamicInterceptionAdvice() 将其他通知统一转换为 MethodInterceptor 环绕通知</li></ol><ul><li><ul><li>MethodBeforeAdviceAdapter 将 @Before  AspectJMethodBeforeAdvice 适配为 MethodBeforeAdviceInterceptor </li><li>AfterReturningAdviceAdapter 将 @AfterReturning  AspectJAfterReturningAdvice 适配为 AfterReturningAdviceInterceptor </li><li>这体现的是适配器设计模式</li></ul></li></ul><ol><li>所谓静态通知，体现在上面方法的 Interceptors 部分，这些通知调用时无需再次检查切点，直接调用即可</li><li>结合目标与环绕通知链，创建 MethodInvocation 对象，通过它完成整个调用</li></ol><h4 id="MethodInvocation调用过程"><a href="#MethodInvocation调用过程" class="headerlink" title="MethodInvocation调用过程"></a>MethodInvocation调用过程</h4><ol><li>proceed() 方法调用链中下一个环绕通知</li><li>每个环绕通知内部继续调用 proceed()</li><li>调用到没有更多通知了, 就调用目标方法</li></ol><p>MethodInvocation 的编程技巧在实现拦截器、过滤器时能用上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Target.foo()&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advice1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            System.out.println(<span class="hljs-string">&quot;Advice1.before()&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();<span class="hljs-comment">// 调用下一个通知或目标</span><br>            System.out.println(<span class="hljs-string">&quot;Advice1.after()&quot;</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Advice2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>            System.out.println(<span class="hljs-string">&quot;Advice2.before()&quot;</span>);<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> invocation.proceed();<span class="hljs-comment">// 调用下一个通知或目标</span><br>            System.out.println(<span class="hljs-string">&quot;Advice2.after()&quot;</span>);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInvocation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInvocation</span> &#123;<br>        <span class="hljs-keyword">private</span> Object target;  <span class="hljs-comment">// 1</span><br>        <span class="hljs-keyword">private</span> Method method;<br>        <span class="hljs-keyword">private</span> Object[] args;<br>        List&lt;MethodInterceptor&gt; methodInterceptorList; <span class="hljs-comment">// 2</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 调用次数</span><br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyInvocation</span><span class="hljs-params">(Object target, Method method, Object[] args, List&lt;MethodInterceptor&gt; methodInterceptorList)</span> &#123;<br>            <span class="hljs-built_in">this</span>.target = target;<br>            <span class="hljs-built_in">this</span>.method = method;<br>            <span class="hljs-built_in">this</span>.args = args;<br>            <span class="hljs-built_in">this</span>.methodInterceptorList = methodInterceptorList;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Method <span class="hljs-title function_">getMethod</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> method;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object[] getArguments() &#123;<br>            <span class="hljs-keyword">return</span> args;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; <span class="hljs-comment">// 调用每一个环绕通知, 调用目标</span><br>            <span class="hljs-keyword">if</span> (count &gt; methodInterceptorList.size()) &#123;<br>                <span class="hljs-comment">// 调用目标， 返回并结束递归</span><br>                <span class="hljs-keyword">return</span> method.invoke(target, args);<br>            &#125;<br>            <span class="hljs-comment">// 逐一调用通知, count + 1</span><br>            <span class="hljs-type">MethodInterceptor</span> <span class="hljs-variable">methodInterceptor</span> <span class="hljs-operator">=</span> methodInterceptorList.get(count++ - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> methodInterceptor.invoke(<span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getThis</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> AccessibleObject <span class="hljs-title function_">getStaticPart</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> method;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">Target</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Target</span>();<br>        List&lt;MethodInterceptor&gt; list = List.of(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Advice1</span>(),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Advice2</span>()<br>        );<br>        <span class="hljs-type">MyInvocation</span> <span class="hljs-variable">invocation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyInvocation</span>(target, Target.class.getMethod(<span class="hljs-string">&quot;foo&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>], list);<br>        invocation.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring容器与bean</title>
    <link href="/2023/03/26/Spring%E5%AE%B9%E5%99%A8%E4%B8%8Ebean/"/>
    <url>/2023/03/26/Spring%E5%AE%B9%E5%99%A8%E4%B8%8Ebean/</url>
    
    <content type="html"><![CDATA[<h2 id="容器接口"><a href="#容器接口" class="headerlink" title="容器接口"></a>容器接口</h2><ul><li><p>BeanFactory 接口，典型功能有：</p></li><li><ul><li>getBean</li></ul></li><li><p>ApplicationContext 接口，是 BeanFactory 的子接口。它扩展了 BeanFactory 接口的功能，如：</p></li><li><ul><li>国际化</li><li>通配符方式获取一组 Resource 资源</li><li>整合 Environment 环境（能通过它获取各种来源的配置信息）</li><li>事件发布与监听，实现组件之间的解耦</li></ul></li></ul><h3 id="BeanFactory与Application的区别"><a href="#BeanFactory与Application的区别" class="headerlink" title="BeanFactory与Application的区别"></a>BeanFactory与Application的区别</h3><ol><li>到底什么是 BeanFactory</li></ol><ul><li><ul><li>它是 ApplicationContext 的父接口</li><li>它才是 Spring 的核心容器, 主要的 ApplicationContext 实现都【组合】了它的功能，【组合】是指 ApplicationContext 的一个重要成员变量就是 BeanFactory</li></ul></li></ul><ol><li>BeanFactory 能干点啥</li></ol><ul><li><ul><li>表面上只有 getBean</li><li>实际上控制反转、基本的依赖注入、直至 Bean 的生命周期的各种功能，都由它的实现类提供</li><li>通过反射查看了它的成员变量 singletonObjects，内部包含了所有的单例 bean</li></ul></li></ul><ol><li>ApplicationContext 比 BeanFactory 多点啥</li></ol><ul><li><ul><li>ApplicationContext 组合并扩展了 BeanFactory 的功能</li><li>国际化、通配符方式获取一组 Resource 资源、整合 Environment 环境、事件发布与监听</li></ul></li></ul><h2 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h2><p>具体实现类：</p><ul><li>DefaultListableBeanFactory，是 BeanFactory 最重要的实现，像<strong>控制反转</strong>和<strong>依赖注入</strong>功能，都是它来实现</li><li>ClassPathXmlApplicationContext，从类路径查找 XML 配置文件，创建容器（旧）</li><li>FileSystemXmlApplicationContext，从磁盘路径查找 XML 配置文件，创建容器（旧）</li><li>XmlWebApplicationContext，传统 SSM 整合时，基于 XML 配置文件的容器（旧）</li><li>AnnotationConfigWebApplicationContext，传统 SSM 整合时，基于 java 配置类的容器（旧）</li><li>AnnotationConfigApplicationContext，Spring boot 中非 web 环境容器（新）</li><li>AnnotationConfigServletWebServerApplicationContext，Spring boot 中 servlet web 环境容器（新）</li><li>AnnotationConfigReactiveWebServerApplicationContext，Spring boot 中 reactive web 环境容器*（新）</li></ul><p>带有 ApplicationContext 的类都是 ApplicationContext 接口的实现，但它们是<strong>组合</strong>了 DefaultListableBeanFactory 的功能，并非继承而来。</p><h3 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h3><ul><li><p>beanFactory 可以<strong>通过 registerBeanDefinition 注册一个 bean definition 对象</strong> </p></li><li><ul><li>我们平时使用的配置类、xml、组件扫描等方式都是生成 bean definition 对象注册到 beanFactory 当中</li><li><strong>bean definition 描述了这个 bean 的创建蓝图：scope 是什么、用构造还是工厂创建、初始化销毁方法是什么，等等</strong></li></ul></li><li><p><strong>beanFactory 需要手动调用 beanFactory 后处理器对它做增强</strong> </p></li><li><ul><li><strong>例如通过解析 @Bean、@ComponentScan  等注解，来补充一些 bean definition</strong></li></ul></li><li><p><strong>beanFactory 需要手动添加 bean 后处理器，以便对后续 bean 的创建过程提供增强</strong> </p></li><li><ul><li><strong>例如 @Autowired，@Resource  等注解的解析都是 bean 后处理器完成的</strong> </li><li>bean 后处理的添加顺序会对解析结果有影响</li></ul></li><li><p>beanFactory 需要手动调用方法来初始化单例</p></li><li><p>beanFactory 需要额外设置才能解析 ${} 与 #{}</p></li></ul><h3 id="ApplicationContext实现类"><a href="#ApplicationContext实现类" class="headerlink" title="ApplicationContext实现类"></a>ApplicationContext实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// ⬇️较为经典的容器, 基于 classpath 下 xml 格式的配置文件来创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testClassPathXmlApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;a02.xml&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;<br>            System.out.println(name);<br>        &#125;<br><br>        System.out.println(context.getBean(Bean2.class).getBean1());<br>    &#125;<br><br>    <span class="hljs-comment">// ⬇️基于磁盘路径下 xml 格式的配置文件来创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFileSystemXmlApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">FileSystemXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSystemXmlApplicationContext</span>(<br>                        <span class="hljs-string">&quot;src\\main\\resources\\a02.xml&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;<br>            System.out.println(name);<br>        &#125;<br><br>        System.out.println(context.getBean(Bean2.class).getBean1());<br>    &#125;<br><br>    <span class="hljs-comment">// ⬇️较为经典的容器, 基于 java 配置类来创建</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnnotationConfigApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>(Config.class);<br><br>        <span class="hljs-keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;<br>            System.out.println(name);<br>        &#125;<br><br>        System.out.println(context.getBean(Bean2.class).getBean1());<br>    &#125;<br><br>    <span class="hljs-comment">// ⬇️较为经典的容器, 基于 java 配置类来创建, 用于 web 环境</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAnnotationConfigServletWebServerApplicationContext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">AnnotationConfigServletWebServerApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigServletWebServerApplicationContext</span>(WebConfig.class);<br>        <span class="hljs-keyword">for</span> (String name : context.getBeanDefinitionNames()) &#123;<br>            System.out.println(name);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Configuration</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> &#123;<br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> ServletWebServerFactory <span class="hljs-title function_">servletWebServerFactory</span><span class="hljs-params">()</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TomcatServletWebServerFactory</span>();<br>        &#125;<br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> DispatcherServlet <span class="hljs-title function_">dispatcherServlet</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispatcherServlet</span>();<br>        &#125;<br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> DispatcherServletRegistrationBean <span class="hljs-title function_">registrationBean</span><span class="hljs-params">(DispatcherServlet dispatcherServlet)</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DispatcherServletRegistrationBean</span>(dispatcherServlet, <span class="hljs-string">&quot;/&quot;</span>);<br>        &#125;<br>        <span class="hljs-meta">@Bean(&quot;/hello&quot;)</span><br>        <span class="hljs-keyword">public</span> Controller <span class="hljs-title function_">controller1</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> (request, response) -&gt; &#123;<br>                response.getWriter().print(<span class="hljs-string">&quot;hello&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Configuration</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span> &#123;<br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> Bean1 <span class="hljs-title function_">bean1</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bean1</span>();<br>        &#125;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-keyword">public</span> Bean2 <span class="hljs-title function_">bean2</span><span class="hljs-params">(Bean1 bean1)</span> &#123;<br>            <span class="hljs-type">Bean2</span> <span class="hljs-variable">bean2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bean2</span>();<br>            bean2.setBean1(bean1);<br>            <span class="hljs-keyword">return</span> bean2;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bean1</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bean2</span> &#123;<br><br>        <span class="hljs-keyword">private</span> Bean1 bean1;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBean1</span><span class="hljs-params">(Bean1 bean1)</span> &#123;<br>            <span class="hljs-built_in">this</span>.bean1 = bean1;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Bean1 <span class="hljs-title function_">getBean1</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> bean1;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h2><p>一个受 Spring 管理的 bean，生命周期主要阶段有</p><ol><li>创建：根据 bean 的构造方法或者工厂方法来创建 bean 实例对象</li><li>依赖注入：根据 @Autowired，@Value  或其它一些手段，为 bean 的成员变量填充值、建立关系 </li><li>初始化：回调各种 Aware 接口，调用对象的各种初始化方法</li><li>销毁：在容器关闭时，会销毁所有单例对象（即调用它们的销毁方法）</li></ol><ul><li><ul><li>prototype 对象也能够销毁，不过需要容器这边主动调用</li></ul></li></ul><p>生命周期中还有一类 bean 后置处理器，会在上述生命周期的前后，提供一些扩展逻辑。</p><h3 id="bean后置处理器"><a href="#bean后置处理器" class="headerlink" title="bean后置处理器"></a>bean后置处理器</h3><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679830784303.png"></p><p>注意：以下都是方法</p><p>创建前后的增强</p><ul><li><p>postProcessBeforeInstantiation （Instantiation：实例化）</p></li><li><ul><li>这里返回的对象若不为 null 会替换掉原本的 bean，并且仅会走 postProcessAfterInitialization 流程</li></ul></li><li><p>postProcessAfterInstantiation </p></li><li><ul><li>这里如果返回 false 会跳过依赖注入阶段</li></ul></li></ul><p>依赖注入前的增强</p><ul><li><p>postProcessProperties </p></li><li><ul><li>如 @Autowired、@Value、@Resource</li></ul></li></ul><p>初始化前后的增强</p><ul><li><p>postProcessBeforeInitialization （Initialization：初始化）</p></li><li><ul><li>这里返回的对象会替换掉原本的 bean</li><li>如 @PostConstruct、@ConfigurationProperties</li></ul></li><li><p>postProcessAfterInitialization </p></li><li><ul><li>这里返回的对象会替换掉原本的 bean</li><li>如代理增强</li></ul></li></ul><p>销毁之前的增强</p><ul><li><p>postProcessBeforeDestruction </p></li><li><ul><li>如 @PreDestroy</li></ul></li></ul><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>Bean的生命周期中通过bean的后置处理器作扩展，使用的是模板方法模式</p><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMethodTemplate</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBeanFactory</span>();<br>        <span class="hljs-comment">//定义不同的子类</span><br>        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="hljs-string">&quot;解析 @Autowired&quot;</span>));<br>        beanFactory.addBeanPostProcessor(bean -&gt; System.out.println(<span class="hljs-string">&quot;解析 @Resource&quot;</span>));<br>        beanFactory.getBean();<br>    &#125;<br><br>    <span class="hljs-comment">// 模板方法  Template Method Pattern</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactory</span> &#123;<br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>            System.out.println(<span class="hljs-string">&quot;构造 &quot;</span> + bean);<br>            System.out.println(<span class="hljs-string">&quot;依赖注入 &quot;</span> + bean); <span class="hljs-comment">// @Autowired, @Resource</span><br>            <span class="hljs-keyword">for</span> (BeanPostProcessor processor : processors) &#123;<br>                processor.inject(bean);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;初始化 &quot;</span> + bean);<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> List&lt;BeanPostProcessor&gt; processors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBeanPostProcessor</span><span class="hljs-params">(BeanPostProcessor processor)</span> &#123;<br>            processors.add(processor);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inject</span><span class="hljs-params">(Object bean)</span>; <span class="hljs-comment">// 对依赖注入阶段的扩展</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="bean-后处理器排序"><a href="#bean-后处理器排序" class="headerlink" title="bean 后处理器排序"></a>bean 后处理器排序</h3><p>对于各种后处理器的执行顺序，有这样的规则：</p><ol><li>实现了 PriorityOrdered 接口的优先级最高</li><li>实现了 Ordered 接口与加了 @Order  注解的平级, 按数字升序 </li><li>其它的排在最后</li></ol><p>代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    bean 后处理的的排序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestProcessOrder</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultListableBeanFactory</span>();<br>        AnnotationConfigUtils.registerAnnotationConfigProcessors(beanFactory);<br><br>        List&lt;BeanPostProcessor&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(<span class="hljs-keyword">new</span> <span class="hljs-title class_">P1</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">P2</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">P3</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">P4</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">P5</span>()));<br>        list.sort(beanFactory.getDependencyComparator());<br><br>        list.forEach(processor-&gt;&#123;<br>            processor.postProcessBeforeInitialization(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(), <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            学到了什么</span><br><span class="hljs-comment">                1. 实现了 PriorityOrdered 接口的优先级最高</span><br><span class="hljs-comment">                2. 实现了 Ordered 接口与加了 @Order 注解的平级, 按数字升序</span><br><span class="hljs-comment">                3. 其它的排在最后</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>    <span class="hljs-meta">@Order(1)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(P1.class);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            log.debug(<span class="hljs-string">&quot;postProcessBeforeInitialization @Order(1)&quot;</span>);<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Order(2)</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(P2.class);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            log.debug(<span class="hljs-string">&quot;postProcessBeforeInitialization @Order(2)&quot;</span>);<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span>, PriorityOrdered &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(P3.class);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            log.debug(<span class="hljs-string">&quot;postProcessBeforeInitialization PriorityOrdered&quot;</span>);<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">100</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P4</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span>, Ordered &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(P4.class);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            log.debug(<span class="hljs-string">&quot;postProcessBeforeInitialization Ordered&quot;</span>);<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">P5</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(P5.class);<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            log.debug(<span class="hljs-string">&quot;postProcessBeforeInitialization&quot;</span>);<br>            <span class="hljs-keyword">return</span> bean;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[DEBUG] <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">30.104</span> [main] com.itheima.a03.TestProcessOrder$P3 - postProcessBeforeInitialization PriorityOrdered <br>[DEBUG] <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">30.108</span> [main] com.itheima.a03.TestProcessOrder$P4 - postProcessBeforeInitialization Ordered <br>[DEBUG] <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">30.108</span> [main] com.itheima.a03.TestProcessOrder$P1 - postProcessBeforeInitialization <span class="hljs-meta">@Order(1)</span> <br>[DEBUG] <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">30.108</span> [main] com.itheima.a03.TestProcessOrder$P2 - postProcessBeforeInitialization <span class="hljs-meta">@Order(2)</span> <br>[DEBUG] <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">30.108</span> [main] com.itheima.a03.TestProcessOrder$P5 - postProcessBeforeInitialization <br></code></pre></td></tr></table></figure><h2 id="Bean-后处理器"><a href="#Bean-后处理器" class="headerlink" title="Bean 后处理器"></a>Bean 后处理器</h2><h3 id="后处理器作用"><a href="#后处理器作用" class="headerlink" title="后处理器作用"></a>后处理器作用</h3><ol><li>@Autowired  等注解的解析属于 bean 生命周期阶段（依赖注入, 初始化）的扩展功能，这些扩展功能由 bean 后处理器来完成 </li><li>每个后处理器各自增强什么功能</li></ol><ul><li><ul><li>AutowiredAnnotationBeanPostProcessor 解析 @Autowired  与 @Value  </li><li>CommonAnnotationBeanPostProcessor 解析 @Resource、@PostConstruct、@PreDestroy  </li><li>ConfigurationPropertiesBindingPostProcessor 解析 @ConfigurationProperties</li></ul></li></ul><ol><li>另外 ContextAnnotationAutowireCandidateResolver 负责获取 @Value  的值，解析 @Qualifier、泛型、@Lazy  等</li></ol><h4 id="Autowired-bean-后处理器运行分析"><a href="#Autowired-bean-后处理器运行分析" class="headerlink" title="@Autowired bean 后处理器运行分析"></a>@Autowired bean 后处理器运行分析</h4><ol><li>AutowiredAnnotationBeanPostProcessor.findAutowiringMetadata 用来获取某个 bean 上加了 @Value  @Autowired  的成员变量，方法参数的信息，表示为 InjectionMetadata </li><li>InjectionMetadata 可以完成依赖注入</li><li>InjectionMetadata 内部根据成员变量，方法参数封装为 DependencyDescriptor 类型</li><li>有了 DependencyDescriptor，就可以利用 beanFactory.doResolveDependency 方法进行基于类型的查找</li></ol><h2 id="BeanFactory-后处理器"><a href="#BeanFactory-后处理器" class="headerlink" title="BeanFactory 后处理器"></a>BeanFactory 后处理器</h2><h3 id="BeanFactory-后处理器的作用"><a href="#BeanFactory-后处理器的作用" class="headerlink" title="BeanFactory 后处理器的作用"></a>BeanFactory 后处理器的作用</h3><ul><li><p>ConfigurationClassPostProcessor 可以解析 </p></li><li><ul><li>@ComponentScan  </li><li>@Bean  </li><li>@Import  </li><li>@ImportResource</li></ul></li><li><p>MapperScannerConfigurer 可以解析 </p></li><li><ul><li>Mapper 接口</li></ul></li></ul><ol><li>@ComponentScan, @Bean, @Mapper  等注解的解析属于核心容器（即 BeanFactory）的扩展功能 </li><li>这些扩展功能由不同的 BeanFactory 后处理器来完成，其实主要就是补充了一些 bean 定义</li></ol><h3 id="ComponentScan底层实现过程"><a href="#ComponentScan底层实现过程" class="headerlink" title="@ComponentScan底层实现过程"></a>@ComponentScan底层实现过程</h3><ol><li><strong>扫描指定包路径下的类文件</strong>。在启动Spring应用程序时，会通过ClassLoader加载应用程序的类，并扫描指定包路径下的所有类文件。Spring框架会使用ClassPathBeanDefinitionScanner类来扫描类路径，并使用ClassPathResource类来表示类路径中的资源文件。</li><li><strong>解析类文件中的注解信息</strong>。扫描完类文件之后，Spring框架会解析类文件中的注解信息，包括@Component、@Service、@Repository等等。根据注解的不同，生成相应的Bean定义对象。</li><li><strong>注册Bean<strong><strong>Definition</strong></strong>对象</strong>。生成BeanDefinition对象之后，Spring框架会将它们注册到Bean工厂中，从而使它们成为可用的Bean对象。在这个过程中，Spring框架会使用BeanDefinitionRegistry接口来注册BeanDefinition对象，并使用BeanDefinitionReaderUtils类来加载Bean定义信息。</li><li><strong>初始化Bean对象</strong>。当Spring框架完成Bean定义的注册之后，会自动初始化所有的Bean对象。在这个过程中，Spring框架会自动处理Bean之间的依赖关系，通过自动装配来实现依赖注入。此外，还会调用所有的@PostConstruct方法来完成Bean的初始化工作。</li></ol><h3 id="Bean底层实现过程"><a href="#Bean底层实现过程" class="headerlink" title="@Bean底层实现过程"></a>@Bean底层实现过程</h3><p>@Bean注解是Spring框架中的一个核心注解，它用于声明一个Bean对象，并将这个对象纳入Spring容器的管理范畴。底层的具体实现过程包括以下几个步骤：</p><ol><li><strong>扫描@Configuration注解。</strong>当Spring容器启动时，它会扫描所有的@Configuration注解，这些注解通常用于指定配置类，也就是包含@Bean注解的类。</li><li><strong>解析@Bean注解。</strong>在扫描到@Configuration注解后，Spring容器会解析其中的@Bean注解，检查注解中是否指定了Bean的名称。如果没有指定名称，Spring容器会使用方法名作为Bean的名称。</li><li><strong>执行@Bean注解的方法。</strong>在解析@Bean注解后，Spring容器会执行其中的方法，并将方法返回的对象作为Bean对象注册到容器中。<strong>如果方法有参数，Spring容器会尝试自动装配这些参数，如果无法自动装配，则会抛出异常。如果有多个Bean对象匹配到了同一个参数类型，则会抛出异常。</strong></li><li><strong>处理Bean对象。</strong>在执行完所有的@Bean注解的方法后，Spring容器会处理这些Bean对象，包括初始化、依赖注入等操作。具体的处理过程取决于Bean对象的作用域、生命周期等属性。</li><li><strong>注册Bean对象。</strong>在处理完所有的Bean对象后，Spring容器会将它们注册到容器中，并且为每个Bean对象分配一个唯一的ID，这个ID通常是一个字符串。我们可以使用这个ID来获取Bean对象，或者使用@Autowired注解来注入Bean对象。</li></ol><h3 id="Mapper-接口在Spring框架中的底层实现"><a href="#Mapper-接口在Spring框架中的底层实现" class="headerlink" title="Mapper 接口在Spring框架中的底层实现"></a>Mapper 接口在Spring框架中的底层实现</h3><p>在Spring框架中，MyBatis的Mapper接口底层实现主要通过动态代理实现。</p><p>MyBatis的Mapper接口主要是定义了数据访问的方法，通过Spring框架和MyBatis框架的结合，我们可以通过Mapper接口的定义，使用Spring提供的动态代理机制来自动生成Mapper接口的实现类。</p><p>具体实现过程如下：</p><ol><li>在Spring配置文件中，需要配置MapperScannerConfigurer来扫描Mapper接口。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.example.mapper&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li>MapperScannerConfigurer(<strong>这是一个BeanFactory的后置处理器</strong>）会扫描指定包下的Mapper接口，然后将这些接口交给SqlSessionFactoryBean（<strong>这个类实现了FactoryBean接口，getObject方法中返回了SqlSessionFactoryBean</strong>）管理，通过动态代理生成实现类。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperScannerConfigurer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span>, InitializingBean &#123;<br><br>    <span class="hljs-keyword">private</span> SqlSessionFactoryBean sqlSessionFactoryBean;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-comment">// 获取指定包下的所有Mapper接口，并将MapperFactoryBean注册为BeanDefinition</span><br>        <span class="hljs-keyword">for</span> (Class&lt;?&gt; mapperClass : <span class="hljs-built_in">this</span>.mapperScanner.scan()) &#123;<br>            <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(MapperFactoryBean.class);<br>            beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;mapperInterface&quot;</span>, mapperClass);<br>            beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>, <span class="hljs-built_in">this</span>.sqlSessionFactoryBean.getObject());<br>            registry.registerBeanDefinition(mapperClass.getName(), beanDefinition);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Assert.notNull(<span class="hljs-built_in">this</span>.sqlSessionFactoryBean, <span class="hljs-string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);<br>        Assert.notNull(<span class="hljs-built_in">this</span>.mapperScanner, <span class="hljs-string">&quot;Property &#x27;mapperScanner&#x27; is required&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Setter for sqlSessionFactoryBean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSqlSessionFactoryBean</span><span class="hljs-params">(SqlSessionFactoryBean sqlSessionFactoryBean)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSessionFactoryBean = sqlSessionFactoryBean;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>MapperFactoryBean是Mapper接口的工厂类，负责生成Mapper接口的实例。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapperFactoryBean</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FactoryBean</span>&lt;T&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> Class&lt;T&gt; mapperInterface;<br><br>    <span class="hljs-keyword">private</span> SqlSession sqlSession;<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//返回具体Mapper接口的代理实现类对象，注册到IoC容器中</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.sqlSession.getMapper(<span class="hljs-built_in">this</span>.mapperInterface);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Class&lt;T&gt; <span class="hljs-title function_">getObjectType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.mapperInterface;<br>    &#125;<br><br>    <span class="hljs-comment">// Setter for sqlSession</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSqlSession</span><span class="hljs-params">(SqlSession sqlSession)</span> &#123;<br>        <span class="hljs-built_in">this</span>.sqlSession = sqlSession;<br>    &#125;<br><br>    <span class="hljs-comment">// Setter for mapperInterface</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMapperInterface</span><span class="hljs-params">(Class&lt;T&gt; mapperInterface)</span> &#123;<br>        <span class="hljs-built_in">this</span>.mapperInterface = mapperInterface;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>最后，我们就可以在业务逻辑中，直接使用@Autowired注解注入Mapper接口的实例，然后调用接口中的方法，实现对数据的访问。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserById</span><span class="hljs-params">(Long id)</span> &#123;<br>        <span class="hljs-keyword">return</span> userMapper.getUserById(id);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>以上就是Mapper接口在Spring框架中的底层实现过程。通过动态代理，我们可以轻松地实现Mapper接口的定义和使用，使得数据访问变得更加简单和方便。</p><h2 id="Aware-接口和-InitializingBean-接口"><a href="#Aware-接口和-InitializingBean-接口" class="headerlink" title="Aware 接口和 InitializingBean 接口"></a>Aware 接口和 InitializingBean 接口</h2><ol><li>Aware 接口提供了一种【内置】 的注入手段，例如</li></ol><ul><li><ul><li>BeanNameAware 注入 bean 的名字</li><li>BeanFactoryAware 注入 BeanFactory 容器</li><li>ApplicationContextAware 注入 ApplicationContext 容器</li><li>EmbeddedValueResolverAware 注入 ${} 解析器</li></ul></li></ul><ol><li>InitializingBean 接口提供了一种【内置】的初始化手段</li><li>对比</li></ol><ul><li><ul><li>内置的注入和初始化不受扩展功能的影响，总会被执行</li><li>而扩展功能受某些情况影响可能会失效</li><li>因此 Spring 框架内部的类常用内置注入和初始化</li></ul></li></ul><h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanNameAware</span>, ApplicationContextAware, InitializingBean &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(MyBean.class);<br>    <span class="hljs-comment">//接口BeanNameAware重写的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanName</span><span class="hljs-params">(String name)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;当前bean &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; 名字叫:&quot;</span> + name);<br>    &#125;<br>    <span class="hljs-comment">//接口ApplicationContextAware重写的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        log.debug(<span class="hljs-string">&quot;当前bean &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; 容器是:&quot;</span> + applicationContext);<br>    &#125;<br>    <span class="hljs-comment">//接口InitializingBean重写的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.debug(<span class="hljs-string">&quot;当前bean &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; 初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">aaa</span><span class="hljs-params">(ApplicationContext applicationContext)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;当前bean &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; 使用@Autowired 容器是:&quot;</span> + applicationContext);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;当前bean &quot;</span> + <span class="hljs-built_in">this</span> + <span class="hljs-string">&quot; 使用@PostConstruct 初始化&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置类-Autowired-失效分析"><a href="#配置类-Autowired-失效分析" class="headerlink" title="配置类 @Autowired 失效分析"></a>配置类 @Autowired 失效分析</h3><p>Java 配置类不包含 BeanFactoryPostProcessor 的情况</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679830915779.png"></p><p>Java 配置类包含 BeanFactoryPostProcessor 的情况，因此要创建其中的 BeanFactoryPostProcessor 必须提前创建 Java 配置类，而此时的 BeanPostProcessor 还未准备好，导致 @Autowired 等注解失效</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679830981263.png"></p><p>对应代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyConfig1</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(MyConfig1.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;注入 ApplicationContext&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span> <span class="hljs-comment">//  ⬅️ 注释或添加 beanFactory 后处理器对应上方两种情况</span><br>    <span class="hljs-keyword">public</span> BeanFactoryPostProcessor <span class="hljs-title function_">processor1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> beanFactory -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;执行 processor1&quot;</span>);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>*<strong>注意*</strong></p><p>解决方法：</p><ul><li>用内置依赖注入和初始化取代扩展依赖注入和初始化</li></ul><h2 id="Bean的初始化与销毁"><a href="#Bean的初始化与销毁" class="headerlink" title="Bean的初始化与销毁"></a>Bean的初始化与销毁</h2><p>Spring 提供了多种初始化手段，除了课堂上讲的 @PostConstruct，@Bean(initMethod)  之外，还可以实现 InitializingBean 接口来进行初始化，如果同一个 bean 用了以上手段声明了 3 个初始化方法，那么它们的执行顺序是 </p><ol><li>@PostConstruct  标注的初始化方法 </li><li>InitializingBean 接口的初始化方法</li><li>@Bean(initMethod)  指定的初始化方法</li></ol><p>与初始化类似，Spring 也提供了多种销毁手段，执行顺序为</p><ol><li>@PreDestroy  标注的销毁方法 </li><li>DisposableBean 接口的销毁方法</li><li>@Bean(destroyMethod)  指定的销毁方法</li></ol><h2 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h2><p>在当前版本的 Spring 和 Spring Boot 程序中，支持五种 Scope</p><ul><li>singleton，容器启动时创建（未设置延迟），容器关闭时销毁</li><li>prototype，每次使用时创建，不会自动销毁，需要调用 DefaultListableBeanFactory.destroyBean(bean) 销毁</li><li>request，每次请求用到此 bean 时创建，请求结束时销毁</li><li>session，每个会话用到此 bean 时创建，会话结束时销毁</li><li>application，web 容器用到此 bean 时创建，容器停止时销毁</li></ul><h3 id="singleton-注入其它-scope-失效"><a href="#singleton-注入其它-scope-失效" class="headerlink" title="singleton 注入其它 scope 失效"></a>singleton 注入其它 scope 失效</h3><p>但要注意，如果在 singleton 注入其它 scope 都会有问题，解决方法有</p><ul><li>@Lazy  </li><li>@Scope(proxyMode  &#x3D; ScopedProxyMode.TARGET_CLASS) </li><li>ObjectFactory 或者 Provider</li><li>ApplicationContext.getBean</li></ul><h3 id="三种具体解决方法"><a href="#三种具体解决方法" class="headerlink" title="三种具体解决方法"></a>三种具体解决方法</h3><h4 id="Lazy"><a href="#Lazy" class="headerlink" title="@Lazy"></a>@Lazy</h4><p>关于@Lazy的介绍具体见这篇文章：<a href="https://www.yuque.com/weiyikai/framework/lb8lnxo0watlztqt">https://www.yuque.com/weiyikai/framework/lb8lnxo0watlztqt</a></p><p>实现原理：</p><p>以单例注入多例为例</p><p>有一个单例对象 E</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(E.class);<br><br>    <span class="hljs-keyword">private</span> F f;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">E</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;E()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setF</span><span class="hljs-params">(F f)</span> &#123;<br>        <span class="hljs-built_in">this</span>.f = f;<br>        log.info(<span class="hljs-string">&quot;setF(F f) &#123;&#125;&quot;</span>, f.getClass());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> F <span class="hljs-title function_">getF</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> f;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要注入的对象 F 期望是多例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">F</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(F.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">F</span><span class="hljs-params">()</span> &#123;<br>        log.info(<span class="hljs-string">&quot;F()&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> context.getBean(E.class);<br><span class="hljs-type">F</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> e.getF();<br><span class="hljs-type">F</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> e.getF();<br>System.out.println(f1);<br>System.out.println(f2);<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">com.itheima.demo.cycle.F@6622fc65<br>com.itheima.demo.cycle.F@6622fc65<br></code></pre></td></tr></table></figure><p>发现它们是同一个对象，而不是期望的多例对象</p><p>对于单例对象来讲，依赖注入仅发生了一次，后续再没有用到多例的 F，因此 E 用的始终是第一次依赖注入的 F</p><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679831022450.png"></p><p>解决</p><ul><li>使用 @Lazy生成代理(就是说加上@Lazy注解，注入的对象便是代理对象) </li><li>代理对象虽然还是同一个，但当每次<strong>使用代理对象的任意方法</strong>时，由代理创建新的 f 对象</li></ul><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679831060844.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">E</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Lazy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setF</span><span class="hljs-params">(F f)</span> &#123;<br>        <span class="hljs-built_in">this</span>.f = f;<br>        log.info(<span class="hljs-string">&quot;setF(F f) &#123;&#125;&quot;</span>, f.getClass());<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>*<strong>注意*</strong></p><ul><li>@Lazy也可以加在成员变量上，但加在 set 方法上的目的是可以观察输出，加在成员变量上就不行了</li><li>@Autowired 加在 set 方法的目的类似</li></ul><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">E: setF(F f) <span class="hljs-keyword">class</span> <span class="hljs-title class_">com</span>.itheima.demo.cycle.F$$EnhancerBySpringCGLIB$$8b54f2bc<br>F: F()<br>com.itheima.demo.cycle.F@3a6f2de3<br>F: F()<br>com.itheima.demo.cycle.F@56303b57<br></code></pre></td></tr></table></figure><p>从输出日志可以看到调用 setF 方法时，f 对象的类型是代理类型</p><h4 id="ApplicationContext-getBean"><a href="#ApplicationContext-getBean" class="headerlink" title="ApplicationContext.getBean"></a>ApplicationContext.getBean</h4><p>在单例 Bean 中注入多例 Bean 时，通过在单例 Bean 中使用 ApplicationContext 的 getBean() 方法获取多例 Bean，而不是通过注入的方式，可以解决多例 Bean 变成单例 Bean 的问题。因为每次获取多例 Bean 都会创建一个新的实例，而不是复用之前创建的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext context;<br><br>    <span class="hljs-keyword">public</span> PrototypeService <span class="hljs-title function_">getPrototypeService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> context.getBean(PrototypeService.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ObjectFactory-或者-Provider"><a href="#ObjectFactory-或者-Provider" class="headerlink" title="ObjectFactory 或者 Provider"></a>ObjectFactory 或者 Provider</h4><p>使用 ObjectFactory 或者 Provider 接口获取多例 Bean，同样可以避免多例 Bean 变成单例 Bean 的问题。因为 ObjectFactory 和 Provider 接口都是延迟加载多例 Bean，每次调用 get() 方法都会创建一个新的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ObjectFactory&lt;PrototypeService&gt; prototypeServiceObjectFactory;<br><br>    <span class="hljs-keyword">public</span> PrototypeService <span class="hljs-title function_">getPrototypeService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> prototypeServiceObjectFactory.getObject();<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> Provider&lt;PrototypeService&gt; prototypeServiceProvider;<br><br>    <span class="hljs-keyword">public</span> PrototypeService <span class="hljs-title function_">getPrototypeService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> prototypeServiceProvider.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程安全集合类</title>
    <link href="/2023/03/26/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2023/03/26/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h2><p><img src="https://cdn.jsdelivr.net/gh/WYK24/blogImage@main/img/1679811041648.png"></p><p>线程安全集合类可以分为三大类： </p><ol><li>遗留的线程安全集合如 Hashtable ， Vector </li><li>使用 Collections 装饰的线程安全集合，如：</li></ol><p>Collections.synchronizedCollection </p><p>Collections.synchronizedList </p><p>Collections.synchronizedMap </p><p>Collections.synchronizedSet </p><p>Collections.synchronizedNavigableMap </p><p>Collections.synchronizedNavigableSet</p><p>Collections.synchronizedSortedMap </p><p>Collections.synchronizedSortedSet </p><ol><li>java.util.concurrent.*</li></ol><p>重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词： </p><p><strong>Blocking、CopyOnWrite、Concurrent</strong></p><ul><li>Blocking 大部分实现基于锁，并提供用来阻塞的方法 </li><li>CopyOnWrite 之类容器修改开销相对较重 </li><li>Concurrent 类型的容器</li></ul><ol><li><ol><li><strong>内部很多操作使用 cas 优化</strong>，一般可以提供较高吞吐量 </li><li><strong>弱一致性</strong></li></ol></li><li><ol><li><ol><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的 </li><li>求大小弱一致性，size 操作未必是 100% 准确 </li><li>读取弱一致性</li></ol></li></ol></li></ol><p>注意：遍历时如果发生了修改，对于非安全容器来讲，使用 <strong>fail-fast</strong> 机制也就是让遍历立刻失败，抛出 </p><p>ConcurrentModifificationException，不再继续遍历 </p><h2 id="ConcurrentHashMap类"><a href="#ConcurrentHashMap类" class="headerlink" title="ConcurrentHashMap类"></a>ConcurrentHashMap类</h2><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>ConcurrentHashMap是Java集合框架中的一个类，它是一个线程安全的哈希表，可以在高并发的情况下进行读写操作，适合于多线程环境下的高效并发访问。</p><p>ConcurrentHashMap的主要特点如下：</p><ol><li>线程安全性：ConcurrentHashMap是线程安全的，可以在多线程环境下并发访问，不需要像HashTable类那样使用同步方法或者加锁来保证线程安全。</li><li>分段锁设计：ConcurrentHashMap内部使用Segment数组来分段锁定。每个Segment就是一个独立的哈希表，拥有自己的锁。这样，在多线程的情况下，每个线程只需要锁住自己所需要访问的Segment，可以有效地提高并发访问性能。</li><li>高效性能：ConcurrentHashMap在多线程并发访问时，能够支持较高的吞吐量，而且可以通过控制Segment的数量，来平衡空间和时间的开销。当需要扩容的时候，只需要扩容其中的一个 Segment，而不需要对整个HashMap进行扩容。</li><li>支持高并发读写：ConcurrentHashMap支持高并发读写，可以在读写操作上分别使用不同的锁。这样，在读操作时，只需要获取读锁，其他读操作可以并行进行。在写操作时，需要获取写锁，此时不允许读和写操作同时进行。</li><li>数据一致性：ConcurrentHashMap虽然是线程安全的，但是在多线程的情况下，可能会存在一些数据不一致的情况。例如，两个线程同时对同一个键进行更新操作，这时候只有一个线程的更新操作会生效，而另一个线程的更新操作将会被忽略。所以，在使用ConcurrentHashMap类时，需要根据具体的需求来确定是否需要保证数据的一致性。</li></ol><p>总的来说，ConcurrentHashMap是一个高效、线程安全、支持高并发访问的哈希表，适合于多线程环境下的高效并发访问。</p><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>ConcurrentHashMap是Java中一个线程安全的哈希表实现，它支持高并发性能和线程安全，而这是通过使用分段锁的方式实现的。下面是ConcurrentHashMap类方法的总结：</p><ol><li>put(Object key, Object value)方法：将键值对存储到ConcurrentHashMap中，如果已存在则更新value值。</li><li>putIfAbsent(Object key, Object value)方法：只有当key不存在时才将键值对存储到ConcurrentHashMap中，否则不做任何操作。</li><li>remove(Object key)方法：从ConcurrentHashMap中移除指定的key-value，如果key不存在则不做任何操作。</li><li>replace(Object key, Object oldValue, Object newValue)方法：如果键为key的键值对存在，且value等于oldValue，则将value更新为newValue。</li><li>replace(Object key, Object value)方法：如果键为key的键值对存在，则将value更新为新的value。</li><li>size()方法：返回ConcurrentHashMap中键值对的数量。</li><li>clear()方法：清空ConcurrentHashMap中所有的键值对。</li><li>containsKey(Object key)方法：如果ConcurrentHashMap中包含键为key的键值对，则返回true。</li><li>containsValue(Object value)方法：如果ConcurrentHashMap中包含指定value的键值对，则返回true。</li><li>get(Object key)方法：返回与指定键相关联的值。</li><li>keySet()方法：返回ConcurrentHashMap中所有键的集合。</li><li>values()方法：返回ConcurrentHashMap中所有值的集合。</li><li>entrySet()方法：返回ConcurrentHashMap中所有键值对的集合。</li></ol><p>总之，ConcurrentHashMap类提供了一系列线程安全的方法，支持高并发的读取和写入操作。它很适合在需要高并发读写操作，而且需要线程安全的场景下使用。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><a href="https://www.nowcoder.com/discuss/460771795130466304?sourceSSR=search">https://www.nowcoder.com/discuss/460771795130466304?sourceSSR=search</a></p><p><a href="https://developer.aliyun.com/article/342013">https://developer.aliyun.com/article/342013</a></p><p><a href="https://www.cnblogs.com/williamjie/p/9099861.html">https://www.cnblogs.com/williamjie/p/9099861.html</a></p><p><a href="https://www.nowcoder.com/discuss/409396995431940096?sourceSSR=search">https://www.nowcoder.com/discuss/409396995431940096?sourceSSR=search</a></p><h3 id="八股笔记"><a href="#八股笔记" class="headerlink" title="八股笔记"></a>八股笔记</h3><p><a href="https://blog.csdn.net/weixin_44936189/article/details/117091687">https://blog.csdn.net/weixin_44936189/article/details/117091687</a></p>]]></content>
    
    
    <categories>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
